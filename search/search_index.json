{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction CardboardCI is a collection of several Docker images intended to be used for continuous integration. All of the images are pre-built and made available through the GitHub Container Registry, but built with the intentions to be usable to with any registry. These images are intended to upgrade automatically and enforce a series of constraints to ensure that they all behave similarly. Intentions The images in this organization were built with efficiency, caching and determinism in mind. They are built using Bazel, with a base image responsible for ensuring core depdendencies are included in all images. The images are intended to be upgraded automatically when dependency upgrades are detected. These will raise a pull request, and automatically merge if the pull request successfully completes the checks. Images IMAGE NAME DESCRIPTION cardboardci/base A base image with common dependencies for CI environments cardboardci/awscli The AWS Command Line Interface (CLI) is a unified tool to manage your AWS services cardboardci/bats Bats is most useful when testing software written in Bash, but you can use it to test any UNIX program cardboardci/cppcheck Static analysis of C/C++ code cardboardci/dbxcli A command line client for Dropbox built using the Go SDK. cardboardci/ecr A unified tool to deploy Docker images to Amazon Elastic Container Registry (ECR) cardboardci/github A command-line tool that makes git easier to use with GitHub cardboardci/gitlab Lab wraps Git or Hub, making it simple to clone, fork, and interact with repositories on GitLab cardboardci/hadolint Dockerfile linter, validate inline bash, written in Haskell cardboardci/htmlhint The static code analysis tool you need for your HTML cardboardci/hugo Hugo is an open-source static site generator cardboardci/luacheck Luacheck is a static analyzer and a linter for Lua cardboardci/markdownlint A Node.js style checker and lint tool for Markdown/CommonMark files cardboardci/netlify Netlify builds, deploys and hosts your netlify services cardboardci/pdf2htmlex Convert PDF to HTML without losing text or format cardboardci/pdftools Command line tools for manipulating pdfs cardboardci/psscriptanalyzer PSScriptAnalyzer is a static code checker for Windows PowerShell modules and scripts cardboardci/pylint Pylint is a Python static code analysis tool which looks for programming errors cardboardci/rsvg Turn SVG files into raster images cardboardci/rubocop A Ruby static code analyzer and formatter, based on the community Ruby style guide cardboardci/shellcheck ShellCheck is a static anaylsis tool that automatically finds bugs in your shell scripts cardboardci/stylelint A mighty, modern style linter cardboardci/surge Surge is static web publishing for Front-End Developers, right from the CLI cardboardci/svgtools Tools for working with Scalable Vector Graphics (SVG) files cardboardci/tflint TFLint is a Terraform linter for detecting errors that can not be detected by terraform plan cardboardci/wkhtmltopdf wkhtmltopdf is a command line tools to render HTML into PDF","title":"Introduction"},{"location":"#introduction","text":"CardboardCI is a collection of several Docker images intended to be used for continuous integration. All of the images are pre-built and made available through the GitHub Container Registry, but built with the intentions to be usable to with any registry. These images are intended to upgrade automatically and enforce a series of constraints to ensure that they all behave similarly.","title":"Introduction"},{"location":"#intentions","text":"The images in this organization were built with efficiency, caching and determinism in mind. They are built using Bazel, with a base image responsible for ensuring core depdendencies are included in all images. The images are intended to be upgraded automatically when dependency upgrades are detected. These will raise a pull request, and automatically merge if the pull request successfully completes the checks.","title":"Intentions"},{"location":"#images","text":"IMAGE NAME DESCRIPTION cardboardci/base A base image with common dependencies for CI environments cardboardci/awscli The AWS Command Line Interface (CLI) is a unified tool to manage your AWS services cardboardci/bats Bats is most useful when testing software written in Bash, but you can use it to test any UNIX program cardboardci/cppcheck Static analysis of C/C++ code cardboardci/dbxcli A command line client for Dropbox built using the Go SDK. cardboardci/ecr A unified tool to deploy Docker images to Amazon Elastic Container Registry (ECR) cardboardci/github A command-line tool that makes git easier to use with GitHub cardboardci/gitlab Lab wraps Git or Hub, making it simple to clone, fork, and interact with repositories on GitLab cardboardci/hadolint Dockerfile linter, validate inline bash, written in Haskell cardboardci/htmlhint The static code analysis tool you need for your HTML cardboardci/hugo Hugo is an open-source static site generator cardboardci/luacheck Luacheck is a static analyzer and a linter for Lua cardboardci/markdownlint A Node.js style checker and lint tool for Markdown/CommonMark files cardboardci/netlify Netlify builds, deploys and hosts your netlify services cardboardci/pdf2htmlex Convert PDF to HTML without losing text or format cardboardci/pdftools Command line tools for manipulating pdfs cardboardci/psscriptanalyzer PSScriptAnalyzer is a static code checker for Windows PowerShell modules and scripts cardboardci/pylint Pylint is a Python static code analysis tool which looks for programming errors cardboardci/rsvg Turn SVG files into raster images cardboardci/rubocop A Ruby static code analyzer and formatter, based on the community Ruby style guide cardboardci/shellcheck ShellCheck is a static anaylsis tool that automatically finds bugs in your shell scripts cardboardci/stylelint A mighty, modern style linter cardboardci/surge Surge is static web publishing for Front-End Developers, right from the CLI cardboardci/svgtools Tools for working with Scalable Vector Graphics (SVG) files cardboardci/tflint TFLint is a Terraform linter for detecting errors that can not be detected by terraform plan cardboardci/wkhtmltopdf wkhtmltopdf is a command line tools to render HTML into PDF","title":"Images"},{"location":"common-base-image/","text":"Common Base Image cardboardci/base is an Ubuntu Docker image created with reproducibility in mind. This image serves as a base image for other CardboardCI images, supplying common dependencies and expected standards. This helps ensure that all images behave similar when chained together or executed in sequence. Any image developed should use this as a base image to avoid unique image configurations that do not work as expected. Getting Started This image is intended to be inherited by other images, either with a Dockerfile or through Bazel builds. The following is a Dockerfile example: FROM ghcr.io/cardboardci/base:20210211 USER root RUN apt-get update && apt-get install -y ... And the following is an example using Bazel: download_pkgs( name = \"apt_get_download\", image_tar = \"//images/base:image.tar\", packages = [ ... ], ) install_pkgs( name = \"apt_get_installed\", image_tar = \"//images/base:image.tar\", installables_tar = \":apt_get_download.tar\", installation_cleanup_commands = \"rm -rf /var/lib/apt/lists/*\", output_image_name = \"apt_get_installed\", ) How This Image Works This image contains the Ubuntu Linux operating system and everything that is considered common among all of the images. This includes but is not limited to: Bash Curl Git SSH jq The full list can be seen in the images/base definition. All images are expected to have these configured and running in the environments. Tagging Scheme This image has the following tagging scheme: cardboardci/base:edge[-version] cardboardci/base:<YYYYMMDD>[-version] edge - This image tag points to the latest version of the Base image. This tag is built from the HEAD of the main branch. The edge tag is intended to be used as a reference version of the image before referencing by either tag or sha. This tag should not be used in continuous integration settings unless experimenting. <YYYYMMDD> - This image tag is a build of the image, referred to by the 4 digit year, a 2 digit month, and the 2 digit day. For example 20210919 would be the build from September 19th 2021. This tag is intended for cases where image usages are frequently updated. -version - This is an optional extension to the tag to specify variants of the image.","title":"Common Base Image"},{"location":"common-base-image/#common-base-image","text":"cardboardci/base is an Ubuntu Docker image created with reproducibility in mind. This image serves as a base image for other CardboardCI images, supplying common dependencies and expected standards. This helps ensure that all images behave similar when chained together or executed in sequence. Any image developed should use this as a base image to avoid unique image configurations that do not work as expected.","title":"Common Base Image"},{"location":"common-base-image/#getting-started","text":"This image is intended to be inherited by other images, either with a Dockerfile or through Bazel builds. The following is a Dockerfile example: FROM ghcr.io/cardboardci/base:20210211 USER root RUN apt-get update && apt-get install -y ... And the following is an example using Bazel: download_pkgs( name = \"apt_get_download\", image_tar = \"//images/base:image.tar\", packages = [ ... ], ) install_pkgs( name = \"apt_get_installed\", image_tar = \"//images/base:image.tar\", installables_tar = \":apt_get_download.tar\", installation_cleanup_commands = \"rm -rf /var/lib/apt/lists/*\", output_image_name = \"apt_get_installed\", )","title":"Getting Started"},{"location":"common-base-image/#how-this-image-works","text":"This image contains the Ubuntu Linux operating system and everything that is considered common among all of the images. This includes but is not limited to: Bash Curl Git SSH jq The full list can be seen in the images/base definition. All images are expected to have these configured and running in the environments.","title":"How This Image Works"},{"location":"common-base-image/#tagging-scheme","text":"This image has the following tagging scheme: cardboardci/base:edge[-version] cardboardci/base:<YYYYMMDD>[-version] edge - This image tag points to the latest version of the Base image. This tag is built from the HEAD of the main branch. The edge tag is intended to be used as a reference version of the image before referencing by either tag or sha. This tag should not be used in continuous integration settings unless experimenting. <YYYYMMDD> - This image tag is a build of the image, referred to by the 4 digit year, a 2 digit month, and the 2 digit day. For example 20210919 would be the build from September 19th 2021. This tag is intended for cases where image usages are frequently updated. -version - This is an optional extension to the tag to specify variants of the image.","title":"Tagging Scheme"},{"location":"container-execution/","text":"Container Execution You may find at some point you need to locally run the container or view the internal contents of the container. Shell Access If you are wishing to experiment with the container, it can be useful to start a shell session inside of the container - to shell into a container, run the following: docker exec -it <container_name> /bin/bash Or if you would like to mount a directory: docker exec -v `pwd`:/workspace -it <container_name> /bin/bash All images have bash installed. Checking the build version If you are experiencing issues with a container, it can be useful to determine the image digest. As each image is deterministic, the digest should map to specific versions. To obtain the build version for the container: docker inspect -f '{{ index .Config.Labels \"org.opencontainers.image.release\" }}' <container_name> Or the image: docker inspect -f '{{ index .Config.Labels \"org.opencontainers.image.release\" }}' ghcr.io/cardboardci/<image_name>","title":"Container Execution"},{"location":"container-execution/#container-execution","text":"You may find at some point you need to locally run the container or view the internal contents of the container.","title":"Container Execution"},{"location":"container-execution/#shell-access","text":"If you are wishing to experiment with the container, it can be useful to start a shell session inside of the container - to shell into a container, run the following: docker exec -it <container_name> /bin/bash Or if you would like to mount a directory: docker exec -v `pwd`:/workspace -it <container_name> /bin/bash All images have bash installed.","title":"Shell Access"},{"location":"container-execution/#checking-the-build-version","text":"If you are experiencing issues with a container, it can be useful to determine the image digest. As each image is deterministic, the digest should map to specific versions. To obtain the build version for the container: docker inspect -f '{{ index .Config.Labels \"org.opencontainers.image.release\" }}' <container_name> Or the image: docker inspect -f '{{ index .Config.Labels \"org.opencontainers.image.release\" }}' ghcr.io/cardboardci/<image_name>","title":"Checking the build version"},{"location":"usages/","text":"Using the containers Intro Continuous Integration services typically offer the ability to run commands in docker containers, with the exact image specified through YAML configurations. You can see this with services like GitHub Actions, CircleCI, or GitLabCI. A recommended approach is to either build the images in a forked repository, or to make use of a mirroring system for ensuring maximum availability of the images in continuous integration. The following is an example of an image running in GitHub Actions: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/awscli:edge with: args: \"aws --version\" Image Structure All of the images have /workspace set as the default working directory, and expect this to be the mounting point for local testing. Any continuous integration service will likely override this, but should ensure the permissions are correctly set. The aim with /workspace is to ensure that any examples, snippets or dotfiles can assume that this directory will be correctly configured as a mount point for running utilities.","title":"Using the containers"},{"location":"usages/#using-the-containers","text":"","title":"Using the containers"},{"location":"usages/#intro","text":"Continuous Integration services typically offer the ability to run commands in docker containers, with the exact image specified through YAML configurations. You can see this with services like GitHub Actions, CircleCI, or GitLabCI. A recommended approach is to either build the images in a forked repository, or to make use of a mirroring system for ensuring maximum availability of the images in continuous integration. The following is an example of an image running in GitHub Actions: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/awscli:edge with: args: \"aws --version\"","title":"Intro"},{"location":"usages/#image-structure","text":"All of the images have /workspace set as the default working directory, and expect this to be the mounting point for local testing. Any continuous integration service will likely override this, but should ensure the permissions are correctly set. The aim with /workspace is to ensure that any examples, snippets or dotfiles can assume that this directory will be correctly configured as a mount point for running utilities.","title":"Image Structure"},{"location":"conventions/no-sudo/","text":"Limited Permissions The default user configured on each of the images ( org.cardboardci.image.user ) does not have sudo permissions, and cannot install dependencies by default. Images are encouraged to be extended, rather than installing dependencies at runtime. This can be inconvenient for experimentation with dependencies when trying to resolve an issue, but is intended to ensure that any rogue dependency cannot sneak into the software deployment pipeline without going through the necessary vetting procedures to be installable. Additionally avoiding installation at runtime helps avoid flakeyness that can show up due to CDN outages, missing integrity checks or permanently moved resources. Pattern for Extension To extend one of the images, the following is a common Dockerfile pattern: FROM ghcr.io/cardboardci/base:20210211 USER root ENV DEPENDENCY_VERSION 5.10.15 RUN apt-get update && \\ apt-get install -y ... && \\ rm -rf /var/lib/apt/lists/* USER cardboardci And the following is an example using Bazel: container_pull( name = \"cardboardci_base\", digest = \"sha256:some_digest_value_here\", registry = \"ghcr.io\", repository = \"cardboardci/base\", ) download_pkgs( name = \"apt_get_download\", image_tar = \"@cardboardci_base//image\", packages = [ ... ], ) install_pkgs( name = \"apt_get_installed\", image_tar = \"//images/base:image.tar\", installables_tar = \":apt_get_download.tar\", installation_cleanup_commands = \"rm -rf /var/lib/apt/lists/*\", output_image_name = \"apt_get_installed\", ) Chaining Images Extending images to add additional dependencies should be used when working with tightly coupled actions or behaviours. Otherwise it is recommended to chain images together leveraging 'steps' offered by most continuous integration services. Chaining images allows for aggressive caching on build machines, and clear failure scenarios for continuous integration pipelines. Bundling dependencies into large images can result in the pipeline becoming unwieldy and suspectible to dependency difficulties.","title":"Limited Permissions"},{"location":"conventions/no-sudo/#limited-permissions","text":"The default user configured on each of the images ( org.cardboardci.image.user ) does not have sudo permissions, and cannot install dependencies by default. Images are encouraged to be extended, rather than installing dependencies at runtime. This can be inconvenient for experimentation with dependencies when trying to resolve an issue, but is intended to ensure that any rogue dependency cannot sneak into the software deployment pipeline without going through the necessary vetting procedures to be installable. Additionally avoiding installation at runtime helps avoid flakeyness that can show up due to CDN outages, missing integrity checks or permanently moved resources.","title":"Limited Permissions"},{"location":"conventions/no-sudo/#pattern-for-extension","text":"To extend one of the images, the following is a common Dockerfile pattern: FROM ghcr.io/cardboardci/base:20210211 USER root ENV DEPENDENCY_VERSION 5.10.15 RUN apt-get update && \\ apt-get install -y ... && \\ rm -rf /var/lib/apt/lists/* USER cardboardci And the following is an example using Bazel: container_pull( name = \"cardboardci_base\", digest = \"sha256:some_digest_value_here\", registry = \"ghcr.io\", repository = \"cardboardci/base\", ) download_pkgs( name = \"apt_get_download\", image_tar = \"@cardboardci_base//image\", packages = [ ... ], ) install_pkgs( name = \"apt_get_installed\", image_tar = \"//images/base:image.tar\", installables_tar = \":apt_get_download.tar\", installation_cleanup_commands = \"rm -rf /var/lib/apt/lists/*\", output_image_name = \"apt_get_installed\", )","title":"Pattern for Extension"},{"location":"conventions/no-sudo/#chaining-images","text":"Extending images to add additional dependencies should be used when working with tightly coupled actions or behaviours. Otherwise it is recommended to chain images together leveraging 'steps' offered by most continuous integration services. Chaining images allows for aggressive caching on build machines, and clear failure scenarios for continuous integration pipelines. Bundling dependencies into large images can result in the pipeline becoming unwieldy and suspectible to dependency difficulties.","title":"Chaining Images"},{"location":"conventions/tagging/","text":"Tagging Scheme The images in the organization have the following tagging scheme: cardboardci/<name>:edge[-version] cardboardci/<name>:<YYYYMMDD>[-version] edge - This image tag points to the latest version of the image. This tag is built from the HEAD of the main branch. The edge tag is intended to be used as a reference version of the image before referencing by either tag or sha. This tag should not be used in continuous integration settings unless experimenting. <YYYYMMDD> - This image tag is a build of the image, referred to by the 4 digit year, a 2 digit month, and the 2 digit day. For example 20210919 would be the build from September 19th 2021. This tag is intended for cases where image usages are frequently updated. -version - This is an optional extension to the tag to specify variants of the image. Recommended Usages The recommended usage is to use the SHA of the image with the tag included as a comment nearby. This uses the most precise version of the image, and includes a reference date for evaluating the age of the image itself. # GitHub Actions jobs: my_first_job: steps: - name: My first step # 20210227 uses: docker://ghcr.io/cardboardci/basE@sha256:e99aef505e9e3a5026a9a2873f2a5e3b029adb5c8f70327672f3a9a7aef2c73a with: args: \"echo hello\" If the image is frequently updated due to automation, then using just the tag is a valid usage.","title":"Tagging Scheme"},{"location":"conventions/tagging/#tagging-scheme","text":"The images in the organization have the following tagging scheme: cardboardci/<name>:edge[-version] cardboardci/<name>:<YYYYMMDD>[-version] edge - This image tag points to the latest version of the image. This tag is built from the HEAD of the main branch. The edge tag is intended to be used as a reference version of the image before referencing by either tag or sha. This tag should not be used in continuous integration settings unless experimenting. <YYYYMMDD> - This image tag is a build of the image, referred to by the 4 digit year, a 2 digit month, and the 2 digit day. For example 20210919 would be the build from September 19th 2021. This tag is intended for cases where image usages are frequently updated. -version - This is an optional extension to the tag to specify variants of the image.","title":"Tagging Scheme"},{"location":"conventions/tagging/#recommended-usages","text":"The recommended usage is to use the SHA of the image with the tag included as a comment nearby. This uses the most precise version of the image, and includes a reference date for evaluating the age of the image itself. # GitHub Actions jobs: my_first_job: steps: - name: My first step # 20210227 uses: docker://ghcr.io/cardboardci/basE@sha256:e99aef505e9e3a5026a9a2873f2a5e3b029adb5c8f70327672f3a9a7aef2c73a with: args: \"echo hello\" If the image is frequently updated due to automation, then using just the tag is a valid usage.","title":"Recommended Usages"},{"location":"conventions/user-and-group/","text":"Understanding the User and Group Docker images often are configured to run in the root user domain of an image. This kind of elevated access for processes inside the container is not necessary. The common scenario for these images is to run a command working off the contents of a mounted volume. Continuous integration services will often make use of the --user flag to use a reduced permission level for clusters. When running locally, the --user flag may not always be specified. In these cases, the cardboardci user acts as a user with minimum permissions to work with the /workspace directory. Verify the user You can see the properties of the default user by running id on the image: docker run cardboardi/<image>:edge id Labels Properties of the default user for every image are made available with the label namespace org.cardboardci.image. . The following are user properties that exist within this namespace: user - The name of the default user uid - The identifier of the default user group - The name of the default user group gid - The identifier of the default user group To obtain any of the properties listed above, you can run this for the container: docker inspect -f '{{ index .Config.Labels \"org.cardboardci.image.<property>\" }}' <container_name> Or the image: docker inspect -f '{{ index .Config.Labels \"org.cardboardci.image.<property>\" }}' ghcr.io/cardboardci/<image_name> Checking the user If you are experiencing issues with one of the containers, it can be useful to check if the issue is due to permissions. Running the container with the root flag ( --user root ) or interactively debugging can be helpful. To run a container with an interactive shell: docker exec --user 'cardboardci' -it <container_name> /bin/bash Or as the root user: docker exec --user 'root' -it <container_name> /bin/bash","title":"Understanding the User and Group"},{"location":"conventions/user-and-group/#understanding-the-user-and-group","text":"Docker images often are configured to run in the root user domain of an image. This kind of elevated access for processes inside the container is not necessary. The common scenario for these images is to run a command working off the contents of a mounted volume. Continuous integration services will often make use of the --user flag to use a reduced permission level for clusters. When running locally, the --user flag may not always be specified. In these cases, the cardboardci user acts as a user with minimum permissions to work with the /workspace directory.","title":"Understanding the User and Group"},{"location":"conventions/user-and-group/#verify-the-user","text":"You can see the properties of the default user by running id on the image: docker run cardboardi/<image>:edge id","title":"Verify the user"},{"location":"conventions/user-and-group/#labels","text":"Properties of the default user for every image are made available with the label namespace org.cardboardci.image. . The following are user properties that exist within this namespace: user - The name of the default user uid - The identifier of the default user group - The name of the default user group gid - The identifier of the default user group To obtain any of the properties listed above, you can run this for the container: docker inspect -f '{{ index .Config.Labels \"org.cardboardci.image.<property>\" }}' <container_name> Or the image: docker inspect -f '{{ index .Config.Labels \"org.cardboardci.image.<property>\" }}' ghcr.io/cardboardci/<image_name>","title":"Labels"},{"location":"conventions/user-and-group/#checking-the-user","text":"If you are experiencing issues with one of the containers, it can be useful to check if the issue is due to permissions. Running the container with the root flag ( --user root ) or interactively debugging can be helpful. To run a container with an interactive shell: docker exec --user 'cardboardci' -it <container_name> /bin/bash Or as the root user: docker exec --user 'root' -it <container_name> /bin/bash","title":"Checking the user"},{"location":"designs/sum-verified-packages/","text":"Sum Verified Rules Investigation Below is an outline of the design idea for checking the integrity of all packages installed into the docker image, to ensure that the installed package is as expected. This is a design idea and not implemented into the code at this time. # Define a package file that is used for download/integrity checks container_luarocks_package( name = \"luarocks_luacheck\", package = \"luacheck\", version = \"1.23.0\", sum = \"4521794f0fba2e20f3bf15846ab5e01d5332e587e9ce81629c7f96c793bb7036\", ) # Download the luarock packages, with the necessary data to perform # integrity checks on the data. The output csv can be used with the # json sums to ensure integrity of the downloaded files. Failing on # an integrity check will just be a pain point # # This outputs a tar, csv and build script container_luarocks_download( name = \"luarocks_download\", image_tar = \"//images/downloader:image.tar\", packages = [ \":luarocks_luacheck\", # other dependencies can be added here ] ) # docker run :integrity will convert the package files into an # index that can be checked by each entry in the downloaded CSVs container_package_integrity( name = \"integrity\", packages = [ \":luarocks_luacheck\", # ... and other json files ], results = [ \":luarocks_download.csv\", ] ) # The tar file is then installed using the existing package manager container_luarocks_install( name = \"luarocks_installed\", image_tar = \"//images/base:image.tar\", installables_tar = \":luarocks_download.tar\", installation_pre_commands = \"\", installation_post_commands = \"\", output_image_name = \"luarocks_installed\", )","title":"Sum Verified Rules Investigation"},{"location":"designs/sum-verified-packages/#sum-verified-rules-investigation","text":"Below is an outline of the design idea for checking the integrity of all packages installed into the docker image, to ensure that the installed package is as expected. This is a design idea and not implemented into the code at this time. # Define a package file that is used for download/integrity checks container_luarocks_package( name = \"luarocks_luacheck\", package = \"luacheck\", version = \"1.23.0\", sum = \"4521794f0fba2e20f3bf15846ab5e01d5332e587e9ce81629c7f96c793bb7036\", ) # Download the luarock packages, with the necessary data to perform # integrity checks on the data. The output csv can be used with the # json sums to ensure integrity of the downloaded files. Failing on # an integrity check will just be a pain point # # This outputs a tar, csv and build script container_luarocks_download( name = \"luarocks_download\", image_tar = \"//images/downloader:image.tar\", packages = [ \":luarocks_luacheck\", # other dependencies can be added here ] ) # docker run :integrity will convert the package files into an # index that can be checked by each entry in the downloaded CSVs container_package_integrity( name = \"integrity\", packages = [ \":luarocks_luacheck\", # ... and other json files ], results = [ \":luarocks_download.csv\", ] ) # The tar file is then installed using the existing package manager container_luarocks_install( name = \"luarocks_installed\", image_tar = \"//images/base:image.tar\", installables_tar = \":luarocks_download.tar\", installation_pre_commands = \"\", installation_post_commands = \"\", output_image_name = \"luarocks_installed\", )","title":"Sum Verified Rules Investigation"},{"location":"images/awscli/","text":"cardboardci/awscli cardboardci/awscli is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities fpr interacting with Amazon Web Services (AWS). The AWS Command Line Interface (CLI) is a unified tool to manage your AWS services. With just one tool to download and configure, you can control multiple AWS services from the command line and automate them through scripts. Getting Started This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/awscli:edge with: args: \"aws --version\" Pull latest image The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/awscli:edge Test interactively Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/awscli:edge /bin/bash Run a basic command To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/awscli:edge aws --version Fundamentals All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"cardboardci/awscli"},{"location":"images/awscli/#cardboardciawscli","text":"cardboardci/awscli is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities fpr interacting with Amazon Web Services (AWS). The AWS Command Line Interface (CLI) is a unified tool to manage your AWS services. With just one tool to download and configure, you can control multiple AWS services from the command line and automate them through scripts.","title":"cardboardci/awscli"},{"location":"images/awscli/#getting-started","text":"This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/awscli:edge with: args: \"aws --version\"","title":"Getting Started"},{"location":"images/awscli/#pull-latest-image","text":"The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/awscli:edge","title":"Pull latest image"},{"location":"images/awscli/#test-interactively","text":"Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/awscli:edge /bin/bash","title":"Test interactively"},{"location":"images/awscli/#run-a-basic-command","text":"To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/awscli:edge aws --version","title":"Run a basic command"},{"location":"images/awscli/#fundamentals","text":"All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"Fundamentals"},{"location":"images/base/","text":"cardboardci/base cardboardci/base is a Docker image built with continuous integration builds in mind. This image serves as a base image for all CardboardCI images. The image is intended to supply all common dependencies for continuous integration images. This image should be used as a base image for all CardboardCI images to avoid unique image configurations that do not work as expected. Getting Started This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/base:edge with: args: \"echo hello\" Pull latest image The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/base:edge Test interactively Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/base:edge /bin/bash Run a basic command To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/base:edge aws --version","title":"cardboardci/base"},{"location":"images/base/#cardboardcibase","text":"cardboardci/base is a Docker image built with continuous integration builds in mind. This image serves as a base image for all CardboardCI images. The image is intended to supply all common dependencies for continuous integration images. This image should be used as a base image for all CardboardCI images to avoid unique image configurations that do not work as expected.","title":"cardboardci/base"},{"location":"images/base/#getting-started","text":"This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/base:edge with: args: \"echo hello\"","title":"Getting Started"},{"location":"images/base/#pull-latest-image","text":"The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/base:edge","title":"Pull latest image"},{"location":"images/base/#test-interactively","text":"Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/base:edge /bin/bash","title":"Test interactively"},{"location":"images/base/#run-a-basic-command","text":"To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/base:edge aws --version","title":"Run a basic command"},{"location":"images/bats/","text":"cardboardci/bats cardboardci/bats is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for orchestrating Bash testing. Bats is a TAP-compliant testing framework for Bash. It provides a simple way to verify that the UNIX programs you write behave as expected. A Bats test file is a Bash script with special syntax for defining test cases. Under the hood, each test case is just a function with a description. #!/usr/bin/env bats @test \"addition using bc\" { result=\"$(echo 2+2 | bc)\" [ \"$result\" -eq 4 ] } @test \"addition using dc\" { result=\"$(echo 2 2+p | dc)\" [ \"$result\" -eq 4 ] } You can see the source repository here . Getting Started This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/bats:edge with: args: \"bats --version\" Pull latest image The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/bats:edge Test interactively Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/bats:edge /bin/bash Run a basic command To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/bats:edge aws --version Fundamentals All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"cardboardci/bats"},{"location":"images/bats/#cardboardcibats","text":"cardboardci/bats is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for orchestrating Bash testing. Bats is a TAP-compliant testing framework for Bash. It provides a simple way to verify that the UNIX programs you write behave as expected. A Bats test file is a Bash script with special syntax for defining test cases. Under the hood, each test case is just a function with a description. #!/usr/bin/env bats @test \"addition using bc\" { result=\"$(echo 2+2 | bc)\" [ \"$result\" -eq 4 ] } @test \"addition using dc\" { result=\"$(echo 2 2+p | dc)\" [ \"$result\" -eq 4 ] } You can see the source repository here .","title":"cardboardci/bats"},{"location":"images/bats/#getting-started","text":"This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/bats:edge with: args: \"bats --version\"","title":"Getting Started"},{"location":"images/bats/#pull-latest-image","text":"The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/bats:edge","title":"Pull latest image"},{"location":"images/bats/#test-interactively","text":"Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/bats:edge /bin/bash","title":"Test interactively"},{"location":"images/bats/#run-a-basic-command","text":"To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/bats:edge aws --version","title":"Run a basic command"},{"location":"images/bats/#fundamentals","text":"All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"Fundamentals"},{"location":"images/cppcheck/","text":"cardboardci/cppcheck cardboardci/cppcheck is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for static analysis of C++. Cppcheck is an analysis tool for C/C++ code. It provides unique code analysis to detect bugs and focuses on detecting undefined behaviour and dangerous coding constructs. The goal is to detect only real errors in the code (i.e. have very few false positives). You can see the source repository here . Getting Started This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/cppcheck:edge with: args: \"cppcheck --version\" Pull latest image The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/cppcheck:edge Test interactively Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/cppcheck:edge /bin/bash Run a basic command To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/cppcheck:edge aws --version Fundamentals All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"cardboardci/cppcheck"},{"location":"images/cppcheck/#cardboardcicppcheck","text":"cardboardci/cppcheck is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for static analysis of C++. Cppcheck is an analysis tool for C/C++ code. It provides unique code analysis to detect bugs and focuses on detecting undefined behaviour and dangerous coding constructs. The goal is to detect only real errors in the code (i.e. have very few false positives). You can see the source repository here .","title":"cardboardci/cppcheck"},{"location":"images/cppcheck/#getting-started","text":"This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/cppcheck:edge with: args: \"cppcheck --version\"","title":"Getting Started"},{"location":"images/cppcheck/#pull-latest-image","text":"The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/cppcheck:edge","title":"Pull latest image"},{"location":"images/cppcheck/#test-interactively","text":"Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/cppcheck:edge /bin/bash","title":"Test interactively"},{"location":"images/cppcheck/#run-a-basic-command","text":"To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/cppcheck:edge aws --version","title":"Run a basic command"},{"location":"images/cppcheck/#fundamentals","text":"All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"Fundamentals"},{"location":"images/dbxcli/","text":"cardboardci/dbxcli cardboardci/dbxcli is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for interfacing with Dropbox. A command line client for Dropbox built using the Go SDK Supports basic file operations like ls, cp, mkdir, mv (via the Files API) Supports search Supports file revisions and file restore Chunked uploads for large files, paginated listing for large directories Supports a growing set of Team operations You can see the source repository here . Getting Started This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/dbxcli:edge with: args: \"dbxcli --version\" Pull latest image The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/dbxcli:edge Test interactively Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/dbxcli:edge /bin/bash Run a basic command To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/dbxcli:edge aws --version Fundamentals All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"cardboardci/dbxcli"},{"location":"images/dbxcli/#cardboardcidbxcli","text":"cardboardci/dbxcli is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for interfacing with Dropbox. A command line client for Dropbox built using the Go SDK Supports basic file operations like ls, cp, mkdir, mv (via the Files API) Supports search Supports file revisions and file restore Chunked uploads for large files, paginated listing for large directories Supports a growing set of Team operations You can see the source repository here .","title":"cardboardci/dbxcli"},{"location":"images/dbxcli/#getting-started","text":"This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/dbxcli:edge with: args: \"dbxcli --version\"","title":"Getting Started"},{"location":"images/dbxcli/#pull-latest-image","text":"The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/dbxcli:edge","title":"Pull latest image"},{"location":"images/dbxcli/#test-interactively","text":"Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/dbxcli:edge /bin/bash","title":"Test interactively"},{"location":"images/dbxcli/#run-a-basic-command","text":"To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/dbxcli:edge aws --version","title":"Run a basic command"},{"location":"images/dbxcli/#fundamentals","text":"All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"Fundamentals"},{"location":"images/ecr/","text":"cardboardci/ecr cardboardci/ecr is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for pushing docker images to AWS Elastic Container Registry (ECR). The AWS Command Line Interface (CLI) is a unified tool to manage your AWS services. With just one tool to download and configure, you can control multiple AWS services from the command line and automate them through scripts. Getting Started This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/ecr:edge with: args: \"aws --version\" Pull latest image The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/ecr:edge Test interactively Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/ecr:edge /bin/bash Run a basic command To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/ecr:edge aws --version Fundamentals All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"cardboardci/ecr"},{"location":"images/ecr/#cardboardciecr","text":"cardboardci/ecr is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for pushing docker images to AWS Elastic Container Registry (ECR). The AWS Command Line Interface (CLI) is a unified tool to manage your AWS services. With just one tool to download and configure, you can control multiple AWS services from the command line and automate them through scripts.","title":"cardboardci/ecr"},{"location":"images/ecr/#getting-started","text":"This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/ecr:edge with: args: \"aws --version\"","title":"Getting Started"},{"location":"images/ecr/#pull-latest-image","text":"The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/ecr:edge","title":"Pull latest image"},{"location":"images/ecr/#test-interactively","text":"Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/ecr:edge /bin/bash","title":"Test interactively"},{"location":"images/ecr/#run-a-basic-command","text":"To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/ecr:edge aws --version","title":"Run a basic command"},{"location":"images/ecr/#fundamentals","text":"All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"Fundamentals"},{"location":"images/github/","text":"cardboardci/github cardboardci/github is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for working with GitHub. gh is GitHub on the command line. It brings pull requests, issues, and other GitHub concepts to the terminal next to where you are already working with git and your code. Getting Started This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/github:edge with: args: \"gh --version\" Pull latest image The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/github:edge Test interactively Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/github:edge /bin/bash Run a basic command To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/github:edge aws --version Fundamentals All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"cardboardci/github"},{"location":"images/github/#cardboardcigithub","text":"cardboardci/github is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for working with GitHub. gh is GitHub on the command line. It brings pull requests, issues, and other GitHub concepts to the terminal next to where you are already working with git and your code.","title":"cardboardci/github"},{"location":"images/github/#getting-started","text":"This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/github:edge with: args: \"gh --version\"","title":"Getting Started"},{"location":"images/github/#pull-latest-image","text":"The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/github:edge","title":"Pull latest image"},{"location":"images/github/#test-interactively","text":"Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/github:edge /bin/bash","title":"Test interactively"},{"location":"images/github/#run-a-basic-command","text":"To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/github:edge aws --version","title":"Run a basic command"},{"location":"images/github/#fundamentals","text":"All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"Fundamentals"},{"location":"images/gitlab/","text":"cardboardci/gitlab cardboardci/gitlab is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for interacting with GitLab. What is GitLabCLI ? It's a cross platform GitLab command line tool to quickly & naturally perform frequent tasks on GitLab project. It does not force you to hand craft json or use other unnatural ways (for example ids, concatenating of strings) like other CLI's to interact with GitLab. It does not have any dependencies. It's self contained .NET core application - you don't need to have .NET installed for it to work. You can see the source repository here . Getting Started This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/gitlab:edge with: args: \"lab --version\" Pull latest image The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/gitlab:edge Test interactively Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/gitlab:edge /bin/bash Run a basic command To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/gitlab:edge aws --version Fundamentals All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"cardboardci/gitlab"},{"location":"images/gitlab/#cardboardcigitlab","text":"cardboardci/gitlab is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for interacting with GitLab. What is GitLabCLI ? It's a cross platform GitLab command line tool to quickly & naturally perform frequent tasks on GitLab project. It does not force you to hand craft json or use other unnatural ways (for example ids, concatenating of strings) like other CLI's to interact with GitLab. It does not have any dependencies. It's self contained .NET core application - you don't need to have .NET installed for it to work. You can see the source repository here .","title":"cardboardci/gitlab"},{"location":"images/gitlab/#getting-started","text":"This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/gitlab:edge with: args: \"lab --version\"","title":"Getting Started"},{"location":"images/gitlab/#pull-latest-image","text":"The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/gitlab:edge","title":"Pull latest image"},{"location":"images/gitlab/#test-interactively","text":"Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/gitlab:edge /bin/bash","title":"Test interactively"},{"location":"images/gitlab/#run-a-basic-command","text":"To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/gitlab:edge aws --version","title":"Run a basic command"},{"location":"images/gitlab/#fundamentals","text":"All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"Fundamentals"},{"location":"images/hadolint/","text":"cardboardci/hadolint cardboardci/hadolint is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for static analysis of Dockerfiles. A smarter Dockerfile linter that helps you build best practice Docker images. The linter is parsing the Dockerfile into an AST and performs rules on top of the AST. It is standing on the shoulders of ShellCheck to lint the Bash code inside RUN instructions. You can see the source repository here . Getting Started This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/hadolint:edge with: args: \"hadolint --version\" Pull latest image The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/hadolint:edge Test interactively Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/hadolint:edge /bin/bash Run a basic command To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/hadolint:edge aws --version Fundamentals All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"cardboardci/hadolint"},{"location":"images/hadolint/#cardboardcihadolint","text":"cardboardci/hadolint is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for static analysis of Dockerfiles. A smarter Dockerfile linter that helps you build best practice Docker images. The linter is parsing the Dockerfile into an AST and performs rules on top of the AST. It is standing on the shoulders of ShellCheck to lint the Bash code inside RUN instructions. You can see the source repository here .","title":"cardboardci/hadolint"},{"location":"images/hadolint/#getting-started","text":"This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/hadolint:edge with: args: \"hadolint --version\"","title":"Getting Started"},{"location":"images/hadolint/#pull-latest-image","text":"The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/hadolint:edge","title":"Pull latest image"},{"location":"images/hadolint/#test-interactively","text":"Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/hadolint:edge /bin/bash","title":"Test interactively"},{"location":"images/hadolint/#run-a-basic-command","text":"To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/hadolint:edge aws --version","title":"Run a basic command"},{"location":"images/hadolint/#fundamentals","text":"All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"Fundamentals"},{"location":"images/htmlhint/","text":"cardboardci/htmlhint cardboardci/htmlhint is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for static analysis of HTML. The static code analysis tool you need for your HTML. You can see the source repository here . Getting Started This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/htmlhint:edge with: args: \"htmlhint --version\" Pull latest image The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/htmlhint:edge Test interactively Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/htmlhint:edge /bin/bash Run a basic command To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/htmlhint:edge aws --version Fundamentals All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"cardboardci/htmlhint"},{"location":"images/htmlhint/#cardboardcihtmlhint","text":"cardboardci/htmlhint is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for static analysis of HTML. The static code analysis tool you need for your HTML. You can see the source repository here .","title":"cardboardci/htmlhint"},{"location":"images/htmlhint/#getting-started","text":"This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/htmlhint:edge with: args: \"htmlhint --version\"","title":"Getting Started"},{"location":"images/htmlhint/#pull-latest-image","text":"The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/htmlhint:edge","title":"Pull latest image"},{"location":"images/htmlhint/#test-interactively","text":"Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/htmlhint:edge /bin/bash","title":"Test interactively"},{"location":"images/htmlhint/#run-a-basic-command","text":"To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/htmlhint:edge aws --version","title":"Run a basic command"},{"location":"images/htmlhint/#fundamentals","text":"All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"Fundamentals"},{"location":"images/hugo/","text":"cardboardci/hugo cardboardci/hugo is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for generating static websites with Hugo. Hugo is one of the most popular open-source static site generators. With its amazing speed and flexibility, Hugo makes building websites fun again. You can see the cli reference here . Getting Started This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/hugo:edge with: args: \"hugo --version\" Pull latest image The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/hugo:edge Test interactively Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/hugo:edge /bin/bash Run a basic command To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/hugo:edge aws --version Fundamentals All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"cardboardci/hugo"},{"location":"images/hugo/#cardboardcihugo","text":"cardboardci/hugo is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for generating static websites with Hugo. Hugo is one of the most popular open-source static site generators. With its amazing speed and flexibility, Hugo makes building websites fun again. You can see the cli reference here .","title":"cardboardci/hugo"},{"location":"images/hugo/#getting-started","text":"This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/hugo:edge with: args: \"hugo --version\"","title":"Getting Started"},{"location":"images/hugo/#pull-latest-image","text":"The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/hugo:edge","title":"Pull latest image"},{"location":"images/hugo/#test-interactively","text":"Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/hugo:edge /bin/bash","title":"Test interactively"},{"location":"images/hugo/#run-a-basic-command","text":"To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/hugo:edge aws --version","title":"Run a basic command"},{"location":"images/hugo/#fundamentals","text":"All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"Fundamentals"},{"location":"images/luacheck/","text":"cardboardci/luacheck cardboardci/luacheck is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for static analysis of Lua. Luacheck is a static analyzer and a linter for Lua. Luacheck detects various issues such as usage of undefined global variables, unused variables and values, accessing uninitialized variables, unreachable code and more. Most aspects of checking are configurable: there are options for defining custom project-related globals, for selecting set of standard globals (version of Lua standard library), for filtering warnings by type and name of related variable, etc. The options can be used on the command line, put into a config or directly into checked files as Lua comments. You can see the cli reference here . Getting Started This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/luacheck:edge with: args: \"luacheck --version\" Pull latest image The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/luacheck:edge Test interactively Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/luacheck:edge /bin/bash Run a basic command To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/luacheck:edge aws --version Fundamentals All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"cardboardci/luacheck"},{"location":"images/luacheck/#cardboardciluacheck","text":"cardboardci/luacheck is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for static analysis of Lua. Luacheck is a static analyzer and a linter for Lua. Luacheck detects various issues such as usage of undefined global variables, unused variables and values, accessing uninitialized variables, unreachable code and more. Most aspects of checking are configurable: there are options for defining custom project-related globals, for selecting set of standard globals (version of Lua standard library), for filtering warnings by type and name of related variable, etc. The options can be used on the command line, put into a config or directly into checked files as Lua comments. You can see the cli reference here .","title":"cardboardci/luacheck"},{"location":"images/luacheck/#getting-started","text":"This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/luacheck:edge with: args: \"luacheck --version\"","title":"Getting Started"},{"location":"images/luacheck/#pull-latest-image","text":"The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/luacheck:edge","title":"Pull latest image"},{"location":"images/luacheck/#test-interactively","text":"Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/luacheck:edge /bin/bash","title":"Test interactively"},{"location":"images/luacheck/#run-a-basic-command","text":"To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/luacheck:edge aws --version","title":"Run a basic command"},{"location":"images/luacheck/#fundamentals","text":"All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"Fundamentals"},{"location":"images/markdownlint/","text":"cardboardci/markdownlint cardboardci/markdownlint is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for static analysis of Markdown. A tool to check markdown files and flag style issues. To have markdownlint check your markdown files, simply run mdl with the filenames as a parameter: mdl README.md Markdownlint can also take a directory, and it will scan all markdown files within the directory (and nested directories): mdl docs/ You can see the cli reference here . Getting Started This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/markdownlint:edge with: args: \"markdownlint --version\" Pull latest image The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/markdownlint:edge Test interactively Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/markdownlint:edge /bin/bash Run a basic command To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/markdownlint:edge aws --version Fundamentals All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"cardboardci/markdownlint"},{"location":"images/markdownlint/#cardboardcimarkdownlint","text":"cardboardci/markdownlint is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for static analysis of Markdown. A tool to check markdown files and flag style issues. To have markdownlint check your markdown files, simply run mdl with the filenames as a parameter: mdl README.md Markdownlint can also take a directory, and it will scan all markdown files within the directory (and nested directories): mdl docs/ You can see the cli reference here .","title":"cardboardci/markdownlint"},{"location":"images/markdownlint/#getting-started","text":"This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/markdownlint:edge with: args: \"markdownlint --version\"","title":"Getting Started"},{"location":"images/markdownlint/#pull-latest-image","text":"The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/markdownlint:edge","title":"Pull latest image"},{"location":"images/markdownlint/#test-interactively","text":"Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/markdownlint:edge /bin/bash","title":"Test interactively"},{"location":"images/markdownlint/#run-a-basic-command","text":"To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/markdownlint:edge aws --version","title":"Run a basic command"},{"location":"images/markdownlint/#fundamentals","text":"All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"Fundamentals"},{"location":"images/netlify/","text":"cardboardci/netlify cardboardci/netlify is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for deploying to netlify. The Netlify CLI facilitates the deployment of websites to Netlify, to improve the site building experience. You can see the cli reference here . Getting Started This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/netlify:edge with: args: \"netlify --version\" Pull latest image The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/netlify:edge Test interactively Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/netlify:edge /bin/bash Run a basic command To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/netlify:edge aws --version Fundamentals All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"cardboardci/netlify"},{"location":"images/netlify/#cardboardcinetlify","text":"cardboardci/netlify is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for deploying to netlify. The Netlify CLI facilitates the deployment of websites to Netlify, to improve the site building experience. You can see the cli reference here .","title":"cardboardci/netlify"},{"location":"images/netlify/#getting-started","text":"This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/netlify:edge with: args: \"netlify --version\"","title":"Getting Started"},{"location":"images/netlify/#pull-latest-image","text":"The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/netlify:edge","title":"Pull latest image"},{"location":"images/netlify/#test-interactively","text":"Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/netlify:edge /bin/bash","title":"Test interactively"},{"location":"images/netlify/#run-a-basic-command","text":"To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/netlify:edge aws --version","title":"Run a basic command"},{"location":"images/netlify/#fundamentals","text":"All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"Fundamentals"},{"location":"images/pdf2htmlex/","text":"cardboardci/pdf2htmlex cardboardci/pdf2htmlex is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for converting PDFs to HTML. pdf2htmlEX renders PDF files in HTML, utilizing modern Web technologies. Academic papers with lots of formulas and figures? Magazines with complicated layouts? No problem! Features: Native HTML text with precise font and location. Flexible output: all-in-one HTML or on demand page loading (needs JavaScript). Moderate file size, sometimes even smaller than PDF. Supporting links, outlines (bookmarks), printing, SVG background, Type 3 fonts and more. You can see the cli reference here . Getting Started This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/pdf2htmlex:edge with: args: \"pdf2htmlex --version\" Pull latest image The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/pdf2htmlex:edge Test interactively Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/pdf2htmlex:edge /bin/bash Run a basic command To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/pdf2htmlex:edge aws --version Fundamentals All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"cardboardci/pdf2htmlex"},{"location":"images/pdf2htmlex/#cardboardcipdf2htmlex","text":"cardboardci/pdf2htmlex is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for converting PDFs to HTML. pdf2htmlEX renders PDF files in HTML, utilizing modern Web technologies. Academic papers with lots of formulas and figures? Magazines with complicated layouts? No problem! Features: Native HTML text with precise font and location. Flexible output: all-in-one HTML or on demand page loading (needs JavaScript). Moderate file size, sometimes even smaller than PDF. Supporting links, outlines (bookmarks), printing, SVG background, Type 3 fonts and more. You can see the cli reference here .","title":"cardboardci/pdf2htmlex"},{"location":"images/pdf2htmlex/#getting-started","text":"This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/pdf2htmlex:edge with: args: \"pdf2htmlex --version\"","title":"Getting Started"},{"location":"images/pdf2htmlex/#pull-latest-image","text":"The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/pdf2htmlex:edge","title":"Pull latest image"},{"location":"images/pdf2htmlex/#test-interactively","text":"Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/pdf2htmlex:edge /bin/bash","title":"Test interactively"},{"location":"images/pdf2htmlex/#run-a-basic-command","text":"To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/pdf2htmlex:edge aws --version","title":"Run a basic command"},{"location":"images/pdf2htmlex/#fundamentals","text":"All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"Fundamentals"},{"location":"images/pdftools/","text":"cardboardci/pdftools cardboardci/pdftools is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for working with PDFs. Scientific articles are typically locked away in PDF format, a format designed primarily for printing but not so great for searching or indexing. The new pdftools package allows for extracting text and metadata from pdf files in R. From the extracted plain-text one could find articles discussing a particular drug or species name, without having to rely on publishers providing metadata, or pay-walled search engines. You can see the cli reference here . Getting Started This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/pdftools:edge with: args: \"pdftools --version\" Pull latest image The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/pdftools:edge Test interactively Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/pdftools:edge /bin/bash Run a basic command To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/pdftools:edge aws --version Fundamentals All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"cardboardci/pdftools"},{"location":"images/pdftools/#cardboardcipdftools","text":"cardboardci/pdftools is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for working with PDFs. Scientific articles are typically locked away in PDF format, a format designed primarily for printing but not so great for searching or indexing. The new pdftools package allows for extracting text and metadata from pdf files in R. From the extracted plain-text one could find articles discussing a particular drug or species name, without having to rely on publishers providing metadata, or pay-walled search engines. You can see the cli reference here .","title":"cardboardci/pdftools"},{"location":"images/pdftools/#getting-started","text":"This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/pdftools:edge with: args: \"pdftools --version\"","title":"Getting Started"},{"location":"images/pdftools/#pull-latest-image","text":"The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/pdftools:edge","title":"Pull latest image"},{"location":"images/pdftools/#test-interactively","text":"Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/pdftools:edge /bin/bash","title":"Test interactively"},{"location":"images/pdftools/#run-a-basic-command","text":"To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/pdftools:edge aws --version","title":"Run a basic command"},{"location":"images/pdftools/#fundamentals","text":"All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"Fundamentals"},{"location":"images/psscriptanalyzer/","text":"cardboardci/psscriptanalyzer cardboardci/psscriptanalyzer is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for static analysis of PowerShell. PSScriptAnalyzer is a static code checker for Windows PowerShell modules and scripts. PSScriptAnalyzer checks the quality of Windows PowerShell code by running a set of rules. The rules are based on PowerShell best practices identified by PowerShell Team and the community. It generates DiagnosticResults (errors and warnings) to inform users about potential code defects and suggests possible solutions for improvements. You can see the cli reference here . Getting Started This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/psscriptanalyzer:edge with: args: \"PSFormatter\" Pull latest image The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/psscriptanalyzer:edge Test interactively Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/psscriptanalyzer:edge /bin/bash Run a basic command To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/psscriptanalyzer:edge aws --version Fundamentals All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"cardboardci/psscriptanalyzer"},{"location":"images/psscriptanalyzer/#cardboardcipsscriptanalyzer","text":"cardboardci/psscriptanalyzer is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for static analysis of PowerShell. PSScriptAnalyzer is a static code checker for Windows PowerShell modules and scripts. PSScriptAnalyzer checks the quality of Windows PowerShell code by running a set of rules. The rules are based on PowerShell best practices identified by PowerShell Team and the community. It generates DiagnosticResults (errors and warnings) to inform users about potential code defects and suggests possible solutions for improvements. You can see the cli reference here .","title":"cardboardci/psscriptanalyzer"},{"location":"images/psscriptanalyzer/#getting-started","text":"This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/psscriptanalyzer:edge with: args: \"PSFormatter\"","title":"Getting Started"},{"location":"images/psscriptanalyzer/#pull-latest-image","text":"The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/psscriptanalyzer:edge","title":"Pull latest image"},{"location":"images/psscriptanalyzer/#test-interactively","text":"Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/psscriptanalyzer:edge /bin/bash","title":"Test interactively"},{"location":"images/psscriptanalyzer/#run-a-basic-command","text":"To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/psscriptanalyzer:edge aws --version","title":"Run a basic command"},{"location":"images/psscriptanalyzer/#fundamentals","text":"All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"Fundamentals"},{"location":"images/pylint/","text":"cardboardci/pylint cardboardci/pylint is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for linting of Python. Pylint is a Python static code analysis tool which looks for programming errors, helps enforcing a coding standard, sniffs for code smells and offers simple refactoring suggestions. It's highly configurable, having special pragmas to control its errors and warnings from within your code, as well as from an extensive configuration file. It is also possible to write your own plugins for adding your own checks or for extending pylint in one way or another. You can see the cli reference here . Getting Started This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/pylint:edge with: args: \"pylint --version\" Pull latest image The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/pylint:edge Test interactively Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/pylint:edge /bin/bash Run a basic command To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/pylint:edge aws --version Fundamentals All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"cardboardci/pylint"},{"location":"images/pylint/#cardboardcipylint","text":"cardboardci/pylint is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for linting of Python. Pylint is a Python static code analysis tool which looks for programming errors, helps enforcing a coding standard, sniffs for code smells and offers simple refactoring suggestions. It's highly configurable, having special pragmas to control its errors and warnings from within your code, as well as from an extensive configuration file. It is also possible to write your own plugins for adding your own checks or for extending pylint in one way or another. You can see the cli reference here .","title":"cardboardci/pylint"},{"location":"images/pylint/#getting-started","text":"This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/pylint:edge with: args: \"pylint --version\"","title":"Getting Started"},{"location":"images/pylint/#pull-latest-image","text":"The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/pylint:edge","title":"Pull latest image"},{"location":"images/pylint/#test-interactively","text":"Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/pylint:edge /bin/bash","title":"Test interactively"},{"location":"images/pylint/#run-a-basic-command","text":"To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/pylint:edge aws --version","title":"Run a basic command"},{"location":"images/pylint/#fundamentals","text":"All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"Fundamentals"},{"location":"images/rsvg/","text":"cardboardci/rsvg cardboardci/rsvg is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for working with Scalable Vector Graphics (SVG). A utility to render Scalable Vector Graphics (SVG), associated with the GNOME Project. It renders SVG files to Cairo surfaces. Cairo is the 2D, antialiased drawing library that GNOME uses to draw things to the screen or to generate output for printing. You can see the cli reference here . Getting Started This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/rsvg:edge with: args: \"rsvg --version\" Pull latest image The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/rsvg:edge Test interactively Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/rsvg:edge /bin/bash Run a basic command To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/rsvg:edge aws --version Fundamentals All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"cardboardci/rsvg"},{"location":"images/rsvg/#cardboardcirsvg","text":"cardboardci/rsvg is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for working with Scalable Vector Graphics (SVG). A utility to render Scalable Vector Graphics (SVG), associated with the GNOME Project. It renders SVG files to Cairo surfaces. Cairo is the 2D, antialiased drawing library that GNOME uses to draw things to the screen or to generate output for printing. You can see the cli reference here .","title":"cardboardci/rsvg"},{"location":"images/rsvg/#getting-started","text":"This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/rsvg:edge with: args: \"rsvg --version\"","title":"Getting Started"},{"location":"images/rsvg/#pull-latest-image","text":"The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/rsvg:edge","title":"Pull latest image"},{"location":"images/rsvg/#test-interactively","text":"Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/rsvg:edge /bin/bash","title":"Test interactively"},{"location":"images/rsvg/#run-a-basic-command","text":"To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/rsvg:edge aws --version","title":"Run a basic command"},{"location":"images/rsvg/#fundamentals","text":"All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"Fundamentals"},{"location":"images/rubocop/","text":"cardboardci/rubocop cardboardci/rubocop is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for static analysis of Ruby. RuboCop is a Ruby static code analyzer and code formatter. Out of the box it will enforce many of the guidelines outlined in the community Ruby Style Guide. RuboCop is extremely flexible and most aspects of its behavior can be tweaked via various configuration options. You can see the cli reference here . Getting Started This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/rubocop:edge with: args: \"rubocop --version\" Pull latest image The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/rubocop:edge Test interactively Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/rubocop:edge /bin/bash Run a basic command To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/rubocop:edge aws --version Fundamentals All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"cardboardci/rubocop"},{"location":"images/rubocop/#cardboardcirubocop","text":"cardboardci/rubocop is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for static analysis of Ruby. RuboCop is a Ruby static code analyzer and code formatter. Out of the box it will enforce many of the guidelines outlined in the community Ruby Style Guide. RuboCop is extremely flexible and most aspects of its behavior can be tweaked via various configuration options. You can see the cli reference here .","title":"cardboardci/rubocop"},{"location":"images/rubocop/#getting-started","text":"This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/rubocop:edge with: args: \"rubocop --version\"","title":"Getting Started"},{"location":"images/rubocop/#pull-latest-image","text":"The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/rubocop:edge","title":"Pull latest image"},{"location":"images/rubocop/#test-interactively","text":"Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/rubocop:edge /bin/bash","title":"Test interactively"},{"location":"images/rubocop/#run-a-basic-command","text":"To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/rubocop:edge aws --version","title":"Run a basic command"},{"location":"images/rubocop/#fundamentals","text":"All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"Fundamentals"},{"location":"images/shellcheck/","text":"cardboardci/shellcheck cardboardci/shellcheck is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for static analysis of Shell scripts. ShellCheck is a GPLv3 tool that gives warnings and suggestions for bash/sh shell scripts: The goals of ShellCheck are: To point out and clarify typical beginner's syntax issues that cause a shell to give cryptic error messages. To point out and clarify typical intermediate level semantic problems that cause a shell to behave strangely and counter-intuitively. To point out subtle caveats, corner cases and pitfalls that may cause an advanced user's otherwise working script to fail under future circumstances. You can see the cli reference here . Getting Started This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/shellcheck:edge with: args: \"shellcheck --version\" Pull latest image The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/shellcheck:edge Test interactively Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/shellcheck:edge /bin/bash Run a basic command To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/shellcheck:edge aws --version Fundamentals All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"cardboardci/shellcheck"},{"location":"images/shellcheck/#cardboardcishellcheck","text":"cardboardci/shellcheck is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for static analysis of Shell scripts. ShellCheck is a GPLv3 tool that gives warnings and suggestions for bash/sh shell scripts: The goals of ShellCheck are: To point out and clarify typical beginner's syntax issues that cause a shell to give cryptic error messages. To point out and clarify typical intermediate level semantic problems that cause a shell to behave strangely and counter-intuitively. To point out subtle caveats, corner cases and pitfalls that may cause an advanced user's otherwise working script to fail under future circumstances. You can see the cli reference here .","title":"cardboardci/shellcheck"},{"location":"images/shellcheck/#getting-started","text":"This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/shellcheck:edge with: args: \"shellcheck --version\"","title":"Getting Started"},{"location":"images/shellcheck/#pull-latest-image","text":"The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/shellcheck:edge","title":"Pull latest image"},{"location":"images/shellcheck/#test-interactively","text":"Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/shellcheck:edge /bin/bash","title":"Test interactively"},{"location":"images/shellcheck/#run-a-basic-command","text":"To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/shellcheck:edge aws --version","title":"Run a basic command"},{"location":"images/shellcheck/#fundamentals","text":"All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"Fundamentals"},{"location":"images/stylelint/","text":"cardboardci/stylelint cardboardci/stylelint is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for linting modern web files. A mighty, modern linter that helps you avoid errors and enforce conventions in your styles. It's mighty because it: understands the latest CSS syntax including custom properties and level 4 selectors extracts embedded styles from HTML, markdown and CSS-in-JS object & template literals parses CSS-like syntaxes like SCSS, Sass, Less and SugarSS has over 170 built-in rules to catch errors, apply limits and enforce stylistic conventions supports plugins so you can create your own rules or make use of plugins written by the community automatically fixes some violations (experimental feature) is well tested with over 10000 unit tests supports shareable configs that you can extend or create your own of is unopinionated so you can tailor the linter to your exact needs You can see the cli reference here . Getting Started This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/stylelint:edge with: args: \"stylelint --version\" Pull latest image The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/stylelint:edge Test interactively Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/stylelint:edge /bin/bash Run a basic command To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/stylelint:edge aws --version Fundamentals All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"cardboardci/stylelint"},{"location":"images/stylelint/#cardboardcistylelint","text":"cardboardci/stylelint is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for linting modern web files. A mighty, modern linter that helps you avoid errors and enforce conventions in your styles. It's mighty because it: understands the latest CSS syntax including custom properties and level 4 selectors extracts embedded styles from HTML, markdown and CSS-in-JS object & template literals parses CSS-like syntaxes like SCSS, Sass, Less and SugarSS has over 170 built-in rules to catch errors, apply limits and enforce stylistic conventions supports plugins so you can create your own rules or make use of plugins written by the community automatically fixes some violations (experimental feature) is well tested with over 10000 unit tests supports shareable configs that you can extend or create your own of is unopinionated so you can tailor the linter to your exact needs You can see the cli reference here .","title":"cardboardci/stylelint"},{"location":"images/stylelint/#getting-started","text":"This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/stylelint:edge with: args: \"stylelint --version\"","title":"Getting Started"},{"location":"images/stylelint/#pull-latest-image","text":"The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/stylelint:edge","title":"Pull latest image"},{"location":"images/stylelint/#test-interactively","text":"Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/stylelint:edge /bin/bash","title":"Test interactively"},{"location":"images/stylelint/#run-a-basic-command","text":"To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/stylelint:edge aws --version","title":"Run a basic command"},{"location":"images/stylelint/#fundamentals","text":"All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"Fundamentals"},{"location":"images/surge/","text":"cardboardci/surge cardboardci/surge is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for deploying to surge.sh. This is the CLI client for the surge.sh hosted service. It\u2019s what gets installed when you run npm install -g surge . This CLI library manages access tokens locally and handles the upload and subsequent reporting when you publish a project using surge. You can see the cli reference here . Getting Started This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/surge:edge with: args: \"surge --version\" Pull latest image The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/surge:edge Test interactively Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/surge:edge /bin/bash Run a basic command To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/surge:edge aws --version Fundamentals All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"cardboardci/surge"},{"location":"images/surge/#cardboardcisurge","text":"cardboardci/surge is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for deploying to surge.sh. This is the CLI client for the surge.sh hosted service. It\u2019s what gets installed when you run npm install -g surge . This CLI library manages access tokens locally and handles the upload and subsequent reporting when you publish a project using surge. You can see the cli reference here .","title":"cardboardci/surge"},{"location":"images/surge/#getting-started","text":"This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/surge:edge with: args: \"surge --version\"","title":"Getting Started"},{"location":"images/surge/#pull-latest-image","text":"The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/surge:edge","title":"Pull latest image"},{"location":"images/surge/#test-interactively","text":"Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/surge:edge /bin/bash","title":"Test interactively"},{"location":"images/surge/#run-a-basic-command","text":"To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/surge:edge aws --version","title":"Run a basic command"},{"location":"images/surge/#fundamentals","text":"All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"Fundamentals"},{"location":"images/svgtools/","text":"cardboardci/svgtools cardboardci/svgtools is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for working with Scalable Vector Graphics (SVG). SVG Tools are a collection of tools for working with vector graphics. You can see the cli reference here . Getting Started This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/svgtools:edge with: args: \"rsvg --version\" Pull latest image The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/svgtools:edge Test interactively Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/svgtools:edge /bin/bash Run a basic command To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/svgtools:edge aws --version Fundamentals All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"cardboardci/svgtools"},{"location":"images/svgtools/#cardboardcisvgtools","text":"cardboardci/svgtools is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for working with Scalable Vector Graphics (SVG). SVG Tools are a collection of tools for working with vector graphics. You can see the cli reference here .","title":"cardboardci/svgtools"},{"location":"images/svgtools/#getting-started","text":"This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/svgtools:edge with: args: \"rsvg --version\"","title":"Getting Started"},{"location":"images/svgtools/#pull-latest-image","text":"The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/svgtools:edge","title":"Pull latest image"},{"location":"images/svgtools/#test-interactively","text":"Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/svgtools:edge /bin/bash","title":"Test interactively"},{"location":"images/svgtools/#run-a-basic-command","text":"To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/svgtools:edge aws --version","title":"Run a basic command"},{"location":"images/svgtools/#fundamentals","text":"All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"Fundamentals"},{"location":"images/tflint/","text":"cardboardci/tflint cardboardci/tflint is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for static analysis of Terraform. TFLint is a Terraform linter focused on possible errors, best practices, etc. You can see the cli reference here . Getting Started This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/tflint:edge with: args: \"awscli --version\" Pull latest image The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/tflint:edge Test interactively Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/tflint:edge /bin/bash Run a basic command To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/tflint:edge aws --version Fundamentals All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"cardboardci/tflint"},{"location":"images/tflint/#cardboardcitflint","text":"cardboardci/tflint is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for static analysis of Terraform. TFLint is a Terraform linter focused on possible errors, best practices, etc. You can see the cli reference here .","title":"cardboardci/tflint"},{"location":"images/tflint/#getting-started","text":"This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/tflint:edge with: args: \"awscli --version\"","title":"Getting Started"},{"location":"images/tflint/#pull-latest-image","text":"The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/tflint:edge","title":"Pull latest image"},{"location":"images/tflint/#test-interactively","text":"Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/tflint:edge /bin/bash","title":"Test interactively"},{"location":"images/tflint/#run-a-basic-command","text":"To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/tflint:edge aws --version","title":"Run a basic command"},{"location":"images/tflint/#fundamentals","text":"All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"Fundamentals"},{"location":"images/wkhtmltopdf/","text":"cardboardci/wkhtmltopdf cardboardci/wkhtmltopdf is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for converting from HTML to PDF. wkhtmltopdf and wkhtmltoimage are open source (LGPLv3) command line tools to render HTML into PDF and various image formats using the Qt WebKit rendering engine. These run entirely \"headless\" and do not require a display or display service. You can see the cli reference here . Getting Started This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/wkhtmltopdf:edge with: args: \"wkhtmltopdf --version\" Pull latest image The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/wkhtmltopdf:edge Test interactively Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/wkhtmltopdf:edge /bin/bash Run a basic command To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/wkhtmltopdf:edge aws --version Fundamentals All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"cardboardci/wkhtmltopdf"},{"location":"images/wkhtmltopdf/#cardboardciwkhtmltopdf","text":"cardboardci/wkhtmltopdf is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for converting from HTML to PDF. wkhtmltopdf and wkhtmltoimage are open source (LGPLv3) command line tools to render HTML into PDF and various image formats using the Qt WebKit rendering engine. These run entirely \"headless\" and do not require a display or display service. You can see the cli reference here .","title":"cardboardci/wkhtmltopdf"},{"location":"images/wkhtmltopdf/#getting-started","text":"This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/wkhtmltopdf:edge with: args: \"wkhtmltopdf --version\"","title":"Getting Started"},{"location":"images/wkhtmltopdf/#pull-latest-image","text":"The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/wkhtmltopdf:edge","title":"Pull latest image"},{"location":"images/wkhtmltopdf/#test-interactively","text":"Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/wkhtmltopdf:edge /bin/bash","title":"Test interactively"},{"location":"images/wkhtmltopdf/#run-a-basic-command","text":"To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/wkhtmltopdf:edge aws --version","title":"Run a basic command"},{"location":"images/wkhtmltopdf/#fundamentals","text":"All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"Fundamentals"}]}