{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction CardboardCI is a collection of Docker images intended to be used for continuous integration. All of the images are pre-built and made available through the GitHub Container Registry. These images are intended to upgrade automatically and enforce a series of constraints to ensure consistent behaviour. Intentions The images in this organization were built with efficiency, caching and determinism in mind. They are built using Bazel, with a base image responsible for ensuring core depdendencies are included in all images. The images are intended to be upgraded automatically when dependency upgrades are detected. These will raise a pull request, and automatically merge if the pull request successfully completes the checks. Images IMAGE NAME DESCRIPTION cardboardci/base A base image with common dependencies for CI environments cardboardci/awscli The AWS Command Line Interface (CLI) is a unified tool to manage your AWS services cardboardci/bats Bats is most useful when testing software written in Bash, but you can use it to test any UNIX program cardboardci/cppcheck Static analysis of C/C++ code cardboardci/dbxcli A command line client for Dropbox built using the Go SDK. cardboardci/ecr A unified tool to deploy Docker images to Amazon Elastic Container Registry (ECR) cardboardci/github A command-line tool that makes git easier to use with GitHub cardboardci/gitlab Lab wraps Git or Hub, making it simple to clone, fork, and interact with repositories on GitLab cardboardci/hadolint Dockerfile linter, validate inline bash, written in Haskell cardboardci/htmlhint The static code analysis tool you need for your HTML cardboardci/hugo Hugo is an open-source static site generator cardboardci/luacheck Luacheck is a static analyzer and a linter for Lua cardboardci/markdownlint A Node.js style checker and lint tool for Markdown/CommonMark files cardboardci/netlify Netlify builds, deploys and hosts your netlify services cardboardci/pdf2htmlex Convert PDF to HTML without losing text or format cardboardci/pdftools Command line tools for manipulating pdfs cardboardci/psscriptanalyzer PSScriptAnalyzer is a static code checker for Windows PowerShell modules and scripts cardboardci/pylint Pylint is a Python static code analysis tool which looks for programming errors cardboardci/rsvg Turn SVG files into raster images cardboardci/rubocop A Ruby static code analyzer and formatter, based on the community Ruby style guide cardboardci/shellcheck ShellCheck is a static anaylsis tool that automatically finds bugs in your shell scripts cardboardci/stylelint A mighty, modern style linter cardboardci/surge Surge is static web publishing for Front-End Developers, right from the CLI cardboardci/svgtools Tools for working with Scalable Vector Graphics (SVG) files cardboardci/tflint TFLint is a Terraform linter for detecting errors that can not be detected by terraform plan cardboardci/wkhtmltopdf wkhtmltopdf is a command line tools to render HTML into PDF","title":"Introduction"},{"location":"#introduction","text":"CardboardCI is a collection of Docker images intended to be used for continuous integration. All of the images are pre-built and made available through the GitHub Container Registry. These images are intended to upgrade automatically and enforce a series of constraints to ensure consistent behaviour.","title":"Introduction"},{"location":"#intentions","text":"The images in this organization were built with efficiency, caching and determinism in mind. They are built using Bazel, with a base image responsible for ensuring core depdendencies are included in all images. The images are intended to be upgraded automatically when dependency upgrades are detected. These will raise a pull request, and automatically merge if the pull request successfully completes the checks.","title":"Intentions"},{"location":"#images","text":"IMAGE NAME DESCRIPTION cardboardci/base A base image with common dependencies for CI environments cardboardci/awscli The AWS Command Line Interface (CLI) is a unified tool to manage your AWS services cardboardci/bats Bats is most useful when testing software written in Bash, but you can use it to test any UNIX program cardboardci/cppcheck Static analysis of C/C++ code cardboardci/dbxcli A command line client for Dropbox built using the Go SDK. cardboardci/ecr A unified tool to deploy Docker images to Amazon Elastic Container Registry (ECR) cardboardci/github A command-line tool that makes git easier to use with GitHub cardboardci/gitlab Lab wraps Git or Hub, making it simple to clone, fork, and interact with repositories on GitLab cardboardci/hadolint Dockerfile linter, validate inline bash, written in Haskell cardboardci/htmlhint The static code analysis tool you need for your HTML cardboardci/hugo Hugo is an open-source static site generator cardboardci/luacheck Luacheck is a static analyzer and a linter for Lua cardboardci/markdownlint A Node.js style checker and lint tool for Markdown/CommonMark files cardboardci/netlify Netlify builds, deploys and hosts your netlify services cardboardci/pdf2htmlex Convert PDF to HTML without losing text or format cardboardci/pdftools Command line tools for manipulating pdfs cardboardci/psscriptanalyzer PSScriptAnalyzer is a static code checker for Windows PowerShell modules and scripts cardboardci/pylint Pylint is a Python static code analysis tool which looks for programming errors cardboardci/rsvg Turn SVG files into raster images cardboardci/rubocop A Ruby static code analyzer and formatter, based on the community Ruby style guide cardboardci/shellcheck ShellCheck is a static anaylsis tool that automatically finds bugs in your shell scripts cardboardci/stylelint A mighty, modern style linter cardboardci/surge Surge is static web publishing for Front-End Developers, right from the CLI cardboardci/svgtools Tools for working with Scalable Vector Graphics (SVG) files cardboardci/tflint TFLint is a Terraform linter for detecting errors that can not be detected by terraform plan cardboardci/wkhtmltopdf wkhtmltopdf is a command line tools to render HTML into PDF","title":"Images"},{"location":"common-base-image/","text":"Common Base Image cardboardci/base is an Ubuntu Docker image created with reproducibility in mind. This image serves as a base image for other CardboardCI images, supplying common dependencies and expected standards. This helps ensure that all images behave similar when chained together or executed in sequence. Any image developed should use this as a base image to avoid unique image configurations. Getting Started This image is intended to be inherited by other images, either with a Dockerfile or through Bazel builds. The following is a Dockerfile example: FROM ghcr.io/cardboardci/base:20210211 USER root RUN apt-get update && apt-get install -y ... And the following is an example using Bazel: download_pkgs( name = \"apt_get_download\", image_tar = \"//images/base:image.tar\", packages = [ ... ], ) install_pkgs( name = \"apt_get_installed\", image_tar = \"//images/base:image.tar\", installables_tar = \":apt_get_download.tar\", installation_cleanup_commands = \"rm -rf /var/lib/apt/lists/*\", output_image_name = \"apt_get_installed\", ) How This Image Works This image contains the Ubuntu Linux operating system and everything that is considered common among all of the images. This includes but is not limited to: Bash Curl Git SSH jq The full list can be seen in the images/base definition. All images are expected to have these configured and running in the environments. Tagging Scheme This image has the following tagging scheme: cardboardci/base:edge[-version] cardboardci/base:<YYYYMMDD>[-version] edge - This image tag points to the latest version of the Base image. This tag is built from the HEAD of the main branch. The edge tag is intended to be used as a reference version of the image before referencing by either tag or sha. This tag should not be used in continuous integration settings unless experimenting. <YYYYMMDD> - This image tag is a build of the image, referred to by the 4 digit year, a 2 digit month, and the 2 digit day. For example 20210919 would be the build from September 19th 2021. This tag is intended for cases where image usages are frequently updated. -version - This is an optional extension to the tag to specify variants of the image.","title":"Common Base Image"},{"location":"common-base-image/#common-base-image","text":"cardboardci/base is an Ubuntu Docker image created with reproducibility in mind. This image serves as a base image for other CardboardCI images, supplying common dependencies and expected standards. This helps ensure that all images behave similar when chained together or executed in sequence. Any image developed should use this as a base image to avoid unique image configurations.","title":"Common Base Image"},{"location":"common-base-image/#getting-started","text":"This image is intended to be inherited by other images, either with a Dockerfile or through Bazel builds. The following is a Dockerfile example: FROM ghcr.io/cardboardci/base:20210211 USER root RUN apt-get update && apt-get install -y ... And the following is an example using Bazel: download_pkgs( name = \"apt_get_download\", image_tar = \"//images/base:image.tar\", packages = [ ... ], ) install_pkgs( name = \"apt_get_installed\", image_tar = \"//images/base:image.tar\", installables_tar = \":apt_get_download.tar\", installation_cleanup_commands = \"rm -rf /var/lib/apt/lists/*\", output_image_name = \"apt_get_installed\", )","title":"Getting Started"},{"location":"common-base-image/#how-this-image-works","text":"This image contains the Ubuntu Linux operating system and everything that is considered common among all of the images. This includes but is not limited to: Bash Curl Git SSH jq The full list can be seen in the images/base definition. All images are expected to have these configured and running in the environments.","title":"How This Image Works"},{"location":"common-base-image/#tagging-scheme","text":"This image has the following tagging scheme: cardboardci/base:edge[-version] cardboardci/base:<YYYYMMDD>[-version] edge - This image tag points to the latest version of the Base image. This tag is built from the HEAD of the main branch. The edge tag is intended to be used as a reference version of the image before referencing by either tag or sha. This tag should not be used in continuous integration settings unless experimenting. <YYYYMMDD> - This image tag is a build of the image, referred to by the 4 digit year, a 2 digit month, and the 2 digit day. For example 20210919 would be the build from September 19th 2021. This tag is intended for cases where image usages are frequently updated. -version - This is an optional extension to the tag to specify variants of the image.","title":"Tagging Scheme"},{"location":"container-execution/","text":"Container Execution You may find at some point you need to locally run the container or view the internal contents of the container. Shell Access If you are wishing to experiment with the container, it can be useful to start a shell session inside of the container - to shell into a container, run the following: docker exec -it <container_name> /bin/bash Or if you would like to mount a directory: docker exec -v `pwd`:/workspace -it <container_name> /bin/bash All images have bash installed. Checking the build version If you are experiencing issues with a container, it can be useful to determine the image digest. As each image is deterministic, the installed versions will be pinned. To obtain the build version for the container: docker inspect -f '{{ index .Config.Labels \"org.opencontainers.image.release\" }}' <container_name> Or the image: docker inspect -f '{{ index .Config.Labels \"org.opencontainers.image.release\" }}' ghcr.io/cardboardci/<image_name>","title":"Container Execution"},{"location":"container-execution/#container-execution","text":"You may find at some point you need to locally run the container or view the internal contents of the container.","title":"Container Execution"},{"location":"container-execution/#shell-access","text":"If you are wishing to experiment with the container, it can be useful to start a shell session inside of the container - to shell into a container, run the following: docker exec -it <container_name> /bin/bash Or if you would like to mount a directory: docker exec -v `pwd`:/workspace -it <container_name> /bin/bash All images have bash installed.","title":"Shell Access"},{"location":"container-execution/#checking-the-build-version","text":"If you are experiencing issues with a container, it can be useful to determine the image digest. As each image is deterministic, the installed versions will be pinned. To obtain the build version for the container: docker inspect -f '{{ index .Config.Labels \"org.opencontainers.image.release\" }}' <container_name> Or the image: docker inspect -f '{{ index .Config.Labels \"org.opencontainers.image.release\" }}' ghcr.io/cardboardci/<image_name>","title":"Checking the build version"},{"location":"using-the-images/","text":"Using the images Continuous Integration services typically offer the ability to run commands in docker containers, with the exact image specified through YAML configurations. You can see this with services like GitHub Actions, CircleCI, or GitLabCI. A recommended approach is to either build the images in a forked repository, or to make use of a mirroring system for ensuring maximum availability of the images in continuous integration. The following is an example of an image running in GitHub Actions: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/awscli:edge with: args: \"aws --version\" Image Structure All of the images have /workspace set as the default working directory, and expect this to be the mounting point for local testing. Any continuous integration service will likely override this, but should ensure the permissions are correctly set. The aim with /workspace is to ensure that any examples, snippets or dotfiles can assume that this directory will be correctly configured as a mount point for running utilities.","title":"Using the images"},{"location":"using-the-images/#using-the-images","text":"Continuous Integration services typically offer the ability to run commands in docker containers, with the exact image specified through YAML configurations. You can see this with services like GitHub Actions, CircleCI, or GitLabCI. A recommended approach is to either build the images in a forked repository, or to make use of a mirroring system for ensuring maximum availability of the images in continuous integration. The following is an example of an image running in GitHub Actions: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/awscli:edge with: args: \"aws --version\"","title":"Using the images"},{"location":"using-the-images/#image-structure","text":"All of the images have /workspace set as the default working directory, and expect this to be the mounting point for local testing. Any continuous integration service will likely override this, but should ensure the permissions are correctly set. The aim with /workspace is to ensure that any examples, snippets or dotfiles can assume that this directory will be correctly configured as a mount point for running utilities.","title":"Image Structure"},{"location":"conventions/no-sudo/","text":"Limited Permissions The default user configured on each of the images ( org.cardboardci.image.user ) does not have sudo permissions, and cannot install dependencies by default. Images are encouraged to be extended, rather than installing dependencies at runtime. This can be inconvenient for experimentation with dependencies when trying to resolve an issue, but is intended to ensure that any rogue dependency cannot sneak into the software deployment pipeline without going through the necessary vetting procedures to be installable. Additionally avoiding installation at runtime helps avoid flakeyness that can show up due to CDN outages, missing integrity checks or permanently moved resources. Pattern for Extension To extend one of the images, the following is a common Dockerfile pattern: FROM ghcr.io/cardboardci/base:20210211 USER root ENV DEPENDENCY_VERSION 5.10.15 RUN apt-get update && \\ apt-get install -y ... && \\ rm -rf /var/lib/apt/lists/* USER cardboardci And the following is an example using Bazel: container_pull( name = \"cardboardci_base\", digest = \"sha256:some_digest_value_here\", registry = \"ghcr.io\", repository = \"cardboardci/base\", ) download_pkgs( name = \"apt_get_download\", image_tar = \"@cardboardci_base//image\", packages = [ ... ], ) install_pkgs( name = \"apt_get_installed\", image_tar = \"//images/base:image.tar\", installables_tar = \":apt_get_download.tar\", installation_cleanup_commands = \"rm -rf /var/lib/apt/lists/*\", output_image_name = \"apt_get_installed\", ) Chaining Images Extending images to add additional dependencies should be used when working with tightly coupled actions or behaviours. Otherwise it is recommended to chain images together leveraging 'steps' offered by most continuous integration services. Chaining images allows for aggressive caching on build machines, and clear failure scenarios for continuous integration pipelines. Bundling dependencies into large images can result in the pipeline becoming unwieldy and suspectible to dependency difficulties.","title":"Limited Permissions"},{"location":"conventions/no-sudo/#limited-permissions","text":"The default user configured on each of the images ( org.cardboardci.image.user ) does not have sudo permissions, and cannot install dependencies by default. Images are encouraged to be extended, rather than installing dependencies at runtime. This can be inconvenient for experimentation with dependencies when trying to resolve an issue, but is intended to ensure that any rogue dependency cannot sneak into the software deployment pipeline without going through the necessary vetting procedures to be installable. Additionally avoiding installation at runtime helps avoid flakeyness that can show up due to CDN outages, missing integrity checks or permanently moved resources.","title":"Limited Permissions"},{"location":"conventions/no-sudo/#pattern-for-extension","text":"To extend one of the images, the following is a common Dockerfile pattern: FROM ghcr.io/cardboardci/base:20210211 USER root ENV DEPENDENCY_VERSION 5.10.15 RUN apt-get update && \\ apt-get install -y ... && \\ rm -rf /var/lib/apt/lists/* USER cardboardci And the following is an example using Bazel: container_pull( name = \"cardboardci_base\", digest = \"sha256:some_digest_value_here\", registry = \"ghcr.io\", repository = \"cardboardci/base\", ) download_pkgs( name = \"apt_get_download\", image_tar = \"@cardboardci_base//image\", packages = [ ... ], ) install_pkgs( name = \"apt_get_installed\", image_tar = \"//images/base:image.tar\", installables_tar = \":apt_get_download.tar\", installation_cleanup_commands = \"rm -rf /var/lib/apt/lists/*\", output_image_name = \"apt_get_installed\", )","title":"Pattern for Extension"},{"location":"conventions/no-sudo/#chaining-images","text":"Extending images to add additional dependencies should be used when working with tightly coupled actions or behaviours. Otherwise it is recommended to chain images together leveraging 'steps' offered by most continuous integration services. Chaining images allows for aggressive caching on build machines, and clear failure scenarios for continuous integration pipelines. Bundling dependencies into large images can result in the pipeline becoming unwieldy and suspectible to dependency difficulties.","title":"Chaining Images"},{"location":"conventions/tagging/","text":"Tagging Scheme The images in the organization have the following tagging scheme: cardboardci/<name>:edge[-version] cardboardci/<name>:<YYYYMMDD>[-version] edge - This image tag points to the latest version of the image. This tag is built from the HEAD of the main branch. The edge tag is intended to be used as a reference version of the image before referencing by either tag or sha. This tag should not be used in continuous integration settings unless experimenting. <YYYYMMDD> - This image tag is a build of the image, referred to by the 4 digit year, a 2 digit month, and the 2 digit day. For example 20210919 would be the build from September 19th 2021. This tag is intended for cases where image usages are frequently updated. -version - This is an optional extension to the tag to specify variants of the image. Recommended Usages The recommended usage is to use the SHA of the image with the tag included as a comment nearby. This uses the most precise version of the image, and includes a reference date for evaluating the age of the image itself. # GitHub Actions jobs: my_first_job: steps: - name: My first step # 20210227 uses: docker://ghcr.io/cardboardci/base@sha256:e99aef505e9e3a5026a9a2873f2a5e3b029adb5c8f70327672f3a9a7aef2c73a with: args: \"echo hello\" If the image is frequently updated due to automation, then using just the tag is a valid usage.","title":"Tagging Scheme"},{"location":"conventions/tagging/#tagging-scheme","text":"The images in the organization have the following tagging scheme: cardboardci/<name>:edge[-version] cardboardci/<name>:<YYYYMMDD>[-version] edge - This image tag points to the latest version of the image. This tag is built from the HEAD of the main branch. The edge tag is intended to be used as a reference version of the image before referencing by either tag or sha. This tag should not be used in continuous integration settings unless experimenting. <YYYYMMDD> - This image tag is a build of the image, referred to by the 4 digit year, a 2 digit month, and the 2 digit day. For example 20210919 would be the build from September 19th 2021. This tag is intended for cases where image usages are frequently updated. -version - This is an optional extension to the tag to specify variants of the image.","title":"Tagging Scheme"},{"location":"conventions/tagging/#recommended-usages","text":"The recommended usage is to use the SHA of the image with the tag included as a comment nearby. This uses the most precise version of the image, and includes a reference date for evaluating the age of the image itself. # GitHub Actions jobs: my_first_job: steps: - name: My first step # 20210227 uses: docker://ghcr.io/cardboardci/base@sha256:e99aef505e9e3a5026a9a2873f2a5e3b029adb5c8f70327672f3a9a7aef2c73a with: args: \"echo hello\" If the image is frequently updated due to automation, then using just the tag is a valid usage.","title":"Recommended Usages"},{"location":"conventions/user-and-group/","text":"Understanding the User and Group Docker images often are configured to run in the root user domain of an image. This kind of elevated access for processes inside the container is not necessary. The common scenario for these images is to run a command working off the contents of a mounted volume. Continuous integration services will often make use of the --user flag to use a reduced permission level for execution. When running locally, the --user flag may not always be specified. In these cases, the cardboardci user acts as a user with minimum permissions to work with the /workspace directory. Verify the user You can see the properties of the default user by running id on the image: docker run cardboardi/<image>:edge id Labels Properties of the default user for every image are made available with the label namespace org.cardboardci.image. . The following are user properties that exist within this namespace: user - The name of the default user uid - The identifier of the default user group - The name of the default user group gid - The identifier of the default user group To obtain any of the properties listed above, you can run this for the container: docker inspect -f '{{ index .Config.Labels \"org.cardboardci.image.<property>\" }}' <container_name> Or the image: docker inspect -f '{{ index .Config.Labels \"org.cardboardci.image.<property>\" }}' ghcr.io/cardboardci/<image_name> Checking the user If you are experiencing issues with one of the containers, it can be useful to check if the issue is due to permissions. Running the container with the root flag ( --user root ) or interactively debugging can be helpful. To run a container with an interactive shell: docker exec --user 'cardboardci' -it <container_name> /bin/bash Or as the root user: docker exec --user 'root' -it <container_name> /bin/bash","title":"Understanding the User and Group"},{"location":"conventions/user-and-group/#understanding-the-user-and-group","text":"Docker images often are configured to run in the root user domain of an image. This kind of elevated access for processes inside the container is not necessary. The common scenario for these images is to run a command working off the contents of a mounted volume. Continuous integration services will often make use of the --user flag to use a reduced permission level for execution. When running locally, the --user flag may not always be specified. In these cases, the cardboardci user acts as a user with minimum permissions to work with the /workspace directory.","title":"Understanding the User and Group"},{"location":"conventions/user-and-group/#verify-the-user","text":"You can see the properties of the default user by running id on the image: docker run cardboardi/<image>:edge id","title":"Verify the user"},{"location":"conventions/user-and-group/#labels","text":"Properties of the default user for every image are made available with the label namespace org.cardboardci.image. . The following are user properties that exist within this namespace: user - The name of the default user uid - The identifier of the default user group - The name of the default user group gid - The identifier of the default user group To obtain any of the properties listed above, you can run this for the container: docker inspect -f '{{ index .Config.Labels \"org.cardboardci.image.<property>\" }}' <container_name> Or the image: docker inspect -f '{{ index .Config.Labels \"org.cardboardci.image.<property>\" }}' ghcr.io/cardboardci/<image_name>","title":"Labels"},{"location":"conventions/user-and-group/#checking-the-user","text":"If you are experiencing issues with one of the containers, it can be useful to check if the issue is due to permissions. Running the container with the root flag ( --user root ) or interactively debugging can be helpful. To run a container with an interactive shell: docker exec --user 'cardboardci' -it <container_name> /bin/bash Or as the root user: docker exec --user 'root' -it <container_name> /bin/bash","title":"Checking the user"},{"location":"designs/images-built-by-bazel/","text":"Image built by Bazel Abstract Images built with Dockerfiles have been using templating or layer-inefficient executions to better follow code-reuse standards. This has introduced more complexity and obfuscated the build harness. This design proposes leveraging bazel to build and test the docker images. This is an adapted design from the repository cardboardci/bazel-docker-awscli Proposal This proposes the introduction of bazel as both the build harness, and the mechanism to build the docker images. This would leverage rules_docker to handle the construction of the images, and orchestrate the execution of tests. This was evaluated in the proof of concept bazel-docker-awscli which determined that the lack of windows support was the limiting factor. Recent developments in environments-as-code has made that issue no longer a problem. Package Manager Rules For the package managers that would need rules, they would follow the format of the existing download_pkgs ( f(deps[]) => tarball ). Most of the package managers used in CardboardCI have some way to download but not install the packages. Here are some examples of the rule usages: download_npm( name = \"pkgs\", image_tar = \"@ubuntu//image\", packages = [ \"surge:0.0.1\", ], # Could we read all of the packages from a file? # packages_file = \":file\" ) If the rule could support a way of providing a file, then the same automated process as now could be used for upgrading the dependencies. The big problem I see with this is that if only 1 dependency changes, we must re-download all of the other dependencies. The option of bazel-ifying each dependency as a rule would create problems with updating (e.g. how to update version). This isn't too bad if there exists a file like so: load(\"@io_bazel_rules_docker//docker/package_managers:download_npm.bzl\", \"download_npm\") download_npm( name = \"pkg_surge\", image_tar = \"@ubuntu//image\", src = \":surge.dep\" ) With the .dep file looking something like this: name=\"surge\" version=\"0.0.1\" Full Example An example of an image built with Bazel is included below: download_pkgs( name = \"apt_get_download\", image_tar = \"//images/base:image.tar\", packages = [\"awscli\"], ) install_pkgs( name = \"apt_get_installed\", image_tar = \"//images/base:image.tar\", installables_tar = \":apt_get_download.tar\", installation_cleanup_commands = \"rm -rf /var/lib/apt/lists/*\", output_image_name = \"apt_get_installed\", ) cardboardci_image( name = \"image\", base = \":apt_get_installed.tar\", labels = { \"org.opencontainers.image.title\": \"awscli\", \"org.opencontainers.image.summary\": \"AWS CLI\", \"org.opencontainers.image.description\": \" The AWS Command Line Interface (CLI) is a unified tool to manage your AWS services\", }, ) cardboardci_test( name = \"test\", configs = [ \"//images/awscli/test_configs:command.yaml\", ], image = \":image\", ) Retrospective Advantages As the above is adapted from the existing proof of concept, the following are some notes made from the advantages of the bazel approach: Tests can be split off into root levels, and applied to all images Standards on metadata can be easily enforced for all images Common fields in labeling can be abstracted away with macros Base image can be built alongside existing images Caching has the potential to speed up the build process (or reduce re-builds) Sum verification of all dependencies can be strictly required Vendoring of the dependencies can be done through macros or additional rules","title":"Image built by Bazel"},{"location":"designs/images-built-by-bazel/#image-built-by-bazel","text":"","title":"Image built by Bazel"},{"location":"designs/images-built-by-bazel/#abstract","text":"Images built with Dockerfiles have been using templating or layer-inefficient executions to better follow code-reuse standards. This has introduced more complexity and obfuscated the build harness. This design proposes leveraging bazel to build and test the docker images. This is an adapted design from the repository cardboardci/bazel-docker-awscli","title":"Abstract"},{"location":"designs/images-built-by-bazel/#proposal","text":"This proposes the introduction of bazel as both the build harness, and the mechanism to build the docker images. This would leverage rules_docker to handle the construction of the images, and orchestrate the execution of tests. This was evaluated in the proof of concept bazel-docker-awscli which determined that the lack of windows support was the limiting factor. Recent developments in environments-as-code has made that issue no longer a problem.","title":"Proposal"},{"location":"designs/images-built-by-bazel/#package-manager-rules","text":"For the package managers that would need rules, they would follow the format of the existing download_pkgs ( f(deps[]) => tarball ). Most of the package managers used in CardboardCI have some way to download but not install the packages. Here are some examples of the rule usages: download_npm( name = \"pkgs\", image_tar = \"@ubuntu//image\", packages = [ \"surge:0.0.1\", ], # Could we read all of the packages from a file? # packages_file = \":file\" ) If the rule could support a way of providing a file, then the same automated process as now could be used for upgrading the dependencies. The big problem I see with this is that if only 1 dependency changes, we must re-download all of the other dependencies. The option of bazel-ifying each dependency as a rule would create problems with updating (e.g. how to update version). This isn't too bad if there exists a file like so: load(\"@io_bazel_rules_docker//docker/package_managers:download_npm.bzl\", \"download_npm\") download_npm( name = \"pkg_surge\", image_tar = \"@ubuntu//image\", src = \":surge.dep\" ) With the .dep file looking something like this: name=\"surge\" version=\"0.0.1\"","title":"Package Manager Rules"},{"location":"designs/images-built-by-bazel/#full-example","text":"An example of an image built with Bazel is included below: download_pkgs( name = \"apt_get_download\", image_tar = \"//images/base:image.tar\", packages = [\"awscli\"], ) install_pkgs( name = \"apt_get_installed\", image_tar = \"//images/base:image.tar\", installables_tar = \":apt_get_download.tar\", installation_cleanup_commands = \"rm -rf /var/lib/apt/lists/*\", output_image_name = \"apt_get_installed\", ) cardboardci_image( name = \"image\", base = \":apt_get_installed.tar\", labels = { \"org.opencontainers.image.title\": \"awscli\", \"org.opencontainers.image.summary\": \"AWS CLI\", \"org.opencontainers.image.description\": \" The AWS Command Line Interface (CLI) is a unified tool to manage your AWS services\", }, ) cardboardci_test( name = \"test\", configs = [ \"//images/awscli/test_configs:command.yaml\", ], image = \":image\", )","title":"Full Example"},{"location":"designs/images-built-by-bazel/#retrospective-advantages","text":"As the above is adapted from the existing proof of concept, the following are some notes made from the advantages of the bazel approach: Tests can be split off into root levels, and applied to all images Standards on metadata can be easily enforced for all images Common fields in labeling can be abstracted away with macros Base image can be built alongside existing images Caching has the potential to speed up the build process (or reduce re-builds) Sum verification of all dependencies can be strictly required Vendoring of the dependencies can be done through macros or additional rules","title":"Retrospective Advantages"},{"location":"designs/sum-verified-packages/","text":"Sum Verified Rules Investigation Abstract Dependencies that are installed onto images built by Bazel are not sum verified. This design proposes a mechanism for in-bazel sum verification of dependencies based on the packages downloaded from the associated package managers. Proposal This proposes the introduction of rules based on each type of package, that would declare the necessary parameter to download the package from its authoritative source. Each rule would be of the form container_*_package , that would at minimum ensure a name , version and sum . This rule would not be responsible for downloading the package itself, as to make it easier to vendor the dependencies into internal data stores. The responsibility of downloading and installing packages would be handled by other macros that would handle downloading and sum verification. An example of the rule can be seen for lua as such: # Define a package file that is used for download/integrity checks container_lua_package( name = \"lua_luacheck\", package = \"luacheck\", version = \"1.23.0\", sum = \"4521794f0fba2e20f3bf15846ab5e01d5332e587e9ce81629c7f96c793bb7036\", ) The container_*_package rule would yield an output file that is used by the container_*_download macro for downloading the packages from an authoritative source. This file is intended to be re-usable, so that it can be used to retrieve the dependencies internal data stores instead of the authoritative source. An example of the macro can be seen for lua as such: # This outputs a tar, csv and build script container_lua_download( name = \"lua_download\", image_tar = \"//images/downloader:image.tar\", packages = [ \":lua_luacheck\", # other dependencies can be added here ] ) When the download is completed, a tar file is available with all of the dependencies downloaded by the macro. Each dependency has its sum generated that placed into a package lock csv file. This CSV file is supplied to an internal verification rule to ensure the dependencies are as expected. The CSV file would be of the format: package,file,version,sum . This file would be supplied to the installation rule. Verification Verification of the downloaded dependencies would be handled by container_pkg_check . This rule would be used internally by the container_*_download macros to assist with caching the downloaded files. Multiple package lock csv files can be provided to the rule, which allow checking sums for An example of the macro can be seen for lua as such: # This outputs a tar, csv and build script container_pkg_check( name = \"image_integrity\", tar = [ \":lua_download.csv\", \":npm_download.csv\", # A type of install that requires a custom `image_tar` \":npm_special_download.csv\", # other package dependencies can be added here ], packages = [ \":lua_luacheck\", \":npm_bazel\", \":npm_specialdependency\", # other dependencies can be added here ] ) Splitting verification into its own rule enables for it to be leveraged by custom/freeform mechanisms of retrieving dependencies outside of the common package managers. The retrieved files can be checked as long as the package lock csv file format is met. Full Example Below is an outline of the design for checking the integrity of all packages installed into the docker image, to ensure that the installed package is as expected. This is a design idea and not implemented into the code at this time. # Define a package file that is used for download/integrity checks container_lua_package( name = \"lua_luacheck\", package = \"luacheck\", version = \"1.23.0\", sum = \"4521794f0fba2e20f3bf15846ab5e01d5332e587e9ce81629c7f96c793bb7036\", ) # Download the luarock packages, with the necessary data to perform # integrity checks on the data. The output csv can be used with the # json sums to ensure integrity of the downloaded files. Failing on # an integrity check will just be a pain point # # This outputs a tar, csv and build script container_lua_download( name = \"lua_download\", image_tar = \"//images/downloader:image.tar\", packages = [ \":lua_luacheck\", # other dependencies can be added here ] ) # docker run :integrity will convert the package files into an # index that can be checked by each entry in the downloaded CSVs container_package_integrity( name = \"integrity\", packages = [ \":lua_luacheck\", # ... and other json files ], results = [ \":lua_download.csv\", ] ) # The tar file is then installed using the existing package manager container_lua_install( name = \"lua_installed\", image_tar = \"//images/base:image.tar\", installables_tar = \":lua_download.tar\", installation_pre_commands = \"\", installation_post_commands = \"\", output_image_name = \"lua_installed\", )","title":"Sum Verified Rules Investigation"},{"location":"designs/sum-verified-packages/#sum-verified-rules-investigation","text":"","title":"Sum Verified Rules Investigation"},{"location":"designs/sum-verified-packages/#abstract","text":"Dependencies that are installed onto images built by Bazel are not sum verified. This design proposes a mechanism for in-bazel sum verification of dependencies based on the packages downloaded from the associated package managers.","title":"Abstract"},{"location":"designs/sum-verified-packages/#proposal","text":"This proposes the introduction of rules based on each type of package, that would declare the necessary parameter to download the package from its authoritative source. Each rule would be of the form container_*_package , that would at minimum ensure a name , version and sum . This rule would not be responsible for downloading the package itself, as to make it easier to vendor the dependencies into internal data stores. The responsibility of downloading and installing packages would be handled by other macros that would handle downloading and sum verification. An example of the rule can be seen for lua as such: # Define a package file that is used for download/integrity checks container_lua_package( name = \"lua_luacheck\", package = \"luacheck\", version = \"1.23.0\", sum = \"4521794f0fba2e20f3bf15846ab5e01d5332e587e9ce81629c7f96c793bb7036\", ) The container_*_package rule would yield an output file that is used by the container_*_download macro for downloading the packages from an authoritative source. This file is intended to be re-usable, so that it can be used to retrieve the dependencies internal data stores instead of the authoritative source. An example of the macro can be seen for lua as such: # This outputs a tar, csv and build script container_lua_download( name = \"lua_download\", image_tar = \"//images/downloader:image.tar\", packages = [ \":lua_luacheck\", # other dependencies can be added here ] ) When the download is completed, a tar file is available with all of the dependencies downloaded by the macro. Each dependency has its sum generated that placed into a package lock csv file. This CSV file is supplied to an internal verification rule to ensure the dependencies are as expected. The CSV file would be of the format: package,file,version,sum . This file would be supplied to the installation rule.","title":"Proposal"},{"location":"designs/sum-verified-packages/#verification","text":"Verification of the downloaded dependencies would be handled by container_pkg_check . This rule would be used internally by the container_*_download macros to assist with caching the downloaded files. Multiple package lock csv files can be provided to the rule, which allow checking sums for An example of the macro can be seen for lua as such: # This outputs a tar, csv and build script container_pkg_check( name = \"image_integrity\", tar = [ \":lua_download.csv\", \":npm_download.csv\", # A type of install that requires a custom `image_tar` \":npm_special_download.csv\", # other package dependencies can be added here ], packages = [ \":lua_luacheck\", \":npm_bazel\", \":npm_specialdependency\", # other dependencies can be added here ] ) Splitting verification into its own rule enables for it to be leveraged by custom/freeform mechanisms of retrieving dependencies outside of the common package managers. The retrieved files can be checked as long as the package lock csv file format is met.","title":"Verification"},{"location":"designs/sum-verified-packages/#full-example","text":"Below is an outline of the design for checking the integrity of all packages installed into the docker image, to ensure that the installed package is as expected. This is a design idea and not implemented into the code at this time. # Define a package file that is used for download/integrity checks container_lua_package( name = \"lua_luacheck\", package = \"luacheck\", version = \"1.23.0\", sum = \"4521794f0fba2e20f3bf15846ab5e01d5332e587e9ce81629c7f96c793bb7036\", ) # Download the luarock packages, with the necessary data to perform # integrity checks on the data. The output csv can be used with the # json sums to ensure integrity of the downloaded files. Failing on # an integrity check will just be a pain point # # This outputs a tar, csv and build script container_lua_download( name = \"lua_download\", image_tar = \"//images/downloader:image.tar\", packages = [ \":lua_luacheck\", # other dependencies can be added here ] ) # docker run :integrity will convert the package files into an # index that can be checked by each entry in the downloaded CSVs container_package_integrity( name = \"integrity\", packages = [ \":lua_luacheck\", # ... and other json files ], results = [ \":lua_download.csv\", ] ) # The tar file is then installed using the existing package manager container_lua_install( name = \"lua_installed\", image_tar = \"//images/base:image.tar\", installables_tar = \":lua_download.tar\", installation_pre_commands = \"\", installation_post_commands = \"\", output_image_name = \"lua_installed\", )","title":"Full Example"},{"location":"images/awscli/","text":"cardboardci/awscli cardboardci/awscli is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for interacting with Amazon Web Services (AWS). The AWS Command Line Interface (CLI) is a unified tool to manage your AWS services. With just one tool to download and configure, you can control multiple AWS services from the command line and automate them through scripts. Getting Started This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/awscli:edge with: args: \"aws --version\" Pull latest image The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/awscli:edge Test interactively Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/awscli:edge /bin/bash Run a basic command To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/awscli:edge aws --version Fundamentals All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"cardboardci/awscli"},{"location":"images/awscli/#cardboardciawscli","text":"cardboardci/awscli is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for interacting with Amazon Web Services (AWS). The AWS Command Line Interface (CLI) is a unified tool to manage your AWS services. With just one tool to download and configure, you can control multiple AWS services from the command line and automate them through scripts.","title":"cardboardci/awscli"},{"location":"images/awscli/#getting-started","text":"This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/awscli:edge with: args: \"aws --version\"","title":"Getting Started"},{"location":"images/awscli/#pull-latest-image","text":"The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/awscli:edge","title":"Pull latest image"},{"location":"images/awscli/#test-interactively","text":"Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/awscli:edge /bin/bash","title":"Test interactively"},{"location":"images/awscli/#run-a-basic-command","text":"To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/awscli:edge aws --version","title":"Run a basic command"},{"location":"images/awscli/#fundamentals","text":"All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"Fundamentals"},{"location":"images/base/","text":"cardboardci/base cardboardci/base is a Docker image built with continuous integration builds in mind. This image serves as a base image for all CardboardCI images. The image is intended to supply all common dependencies for continuous integration images. This image should be used as a base image for all CardboardCI images to avoid unique image configurations that do not work as expected. Getting Started This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/base:edge with: args: \"echo hello\" Pull latest image The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/base:edge Test interactively Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/base:edge /bin/bash Run a basic command To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/base:edge echo hello","title":"cardboardci/base"},{"location":"images/base/#cardboardcibase","text":"cardboardci/base is a Docker image built with continuous integration builds in mind. This image serves as a base image for all CardboardCI images. The image is intended to supply all common dependencies for continuous integration images. This image should be used as a base image for all CardboardCI images to avoid unique image configurations that do not work as expected.","title":"cardboardci/base"},{"location":"images/base/#getting-started","text":"This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/base:edge with: args: \"echo hello\"","title":"Getting Started"},{"location":"images/base/#pull-latest-image","text":"The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/base:edge","title":"Pull latest image"},{"location":"images/base/#test-interactively","text":"Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/base:edge /bin/bash","title":"Test interactively"},{"location":"images/base/#run-a-basic-command","text":"To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/base:edge echo hello","title":"Run a basic command"},{"location":"images/bats/","text":"cardboardci/bats cardboardci/bats is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for orchestrating Bash testing. Bats is a TAP-compliant testing framework for Bash. It provides a simple way to verify that the UNIX programs you write behave as expected. A Bats test file is a Bash script with special syntax for defining test cases. Under the hood, each test case is just a function with a description. #!/usr/bin/env bats @test \"addition using bc\" { result=\"$(echo 2+2 | bc)\" [ \"$result\" -eq 4 ] } @test \"addition using dc\" { result=\"$(echo 2 2+p | dc)\" [ \"$result\" -eq 4 ] } You can see the source repository here . Getting Started This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/bats:edge with: args: \"bats --version\" Pull latest image The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/bats:edge Test interactively Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/bats:edge /bin/bash Run a basic command To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/bats:edge bats --version Fundamentals All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"cardboardci/bats"},{"location":"images/bats/#cardboardcibats","text":"cardboardci/bats is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for orchestrating Bash testing. Bats is a TAP-compliant testing framework for Bash. It provides a simple way to verify that the UNIX programs you write behave as expected. A Bats test file is a Bash script with special syntax for defining test cases. Under the hood, each test case is just a function with a description. #!/usr/bin/env bats @test \"addition using bc\" { result=\"$(echo 2+2 | bc)\" [ \"$result\" -eq 4 ] } @test \"addition using dc\" { result=\"$(echo 2 2+p | dc)\" [ \"$result\" -eq 4 ] } You can see the source repository here .","title":"cardboardci/bats"},{"location":"images/bats/#getting-started","text":"This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/bats:edge with: args: \"bats --version\"","title":"Getting Started"},{"location":"images/bats/#pull-latest-image","text":"The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/bats:edge","title":"Pull latest image"},{"location":"images/bats/#test-interactively","text":"Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/bats:edge /bin/bash","title":"Test interactively"},{"location":"images/bats/#run-a-basic-command","text":"To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/bats:edge bats --version","title":"Run a basic command"},{"location":"images/bats/#fundamentals","text":"All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"Fundamentals"},{"location":"images/cppcheck/","text":"cardboardci/cppcheck cardboardci/cppcheck is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for static analysis of C++. Cppcheck is an analysis tool for C/C++ code. It provides unique code analysis to detect bugs and focuses on detecting undefined behaviour and dangerous coding constructs. The goal is to detect only real errors in the code (i.e. have very few false positives). You can see the source repository here . Getting Started This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/cppcheck:edge with: args: \"cppcheck --version\" Pull latest image The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/cppcheck:edge Test interactively Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/cppcheck:edge /bin/bash Run a basic command To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/cppcheck:edge cppcheck --version Fundamentals All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"cardboardci/cppcheck"},{"location":"images/cppcheck/#cardboardcicppcheck","text":"cardboardci/cppcheck is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for static analysis of C++. Cppcheck is an analysis tool for C/C++ code. It provides unique code analysis to detect bugs and focuses on detecting undefined behaviour and dangerous coding constructs. The goal is to detect only real errors in the code (i.e. have very few false positives). You can see the source repository here .","title":"cardboardci/cppcheck"},{"location":"images/cppcheck/#getting-started","text":"This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/cppcheck:edge with: args: \"cppcheck --version\"","title":"Getting Started"},{"location":"images/cppcheck/#pull-latest-image","text":"The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/cppcheck:edge","title":"Pull latest image"},{"location":"images/cppcheck/#test-interactively","text":"Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/cppcheck:edge /bin/bash","title":"Test interactively"},{"location":"images/cppcheck/#run-a-basic-command","text":"To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/cppcheck:edge cppcheck --version","title":"Run a basic command"},{"location":"images/cppcheck/#fundamentals","text":"All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"Fundamentals"},{"location":"images/dbxcli/","text":"cardboardci/dbxcli cardboardci/dbxcli is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for interfacing with Dropbox. A command line client for Dropbox built using the Go SDK Supports basic file operations like ls, cp, mkdir, mv (via the Files API) Supports search Supports file revisions and file restore Chunked uploads for large files, paginated listing for large directories Supports a growing set of Team operations You can see the source repository here . Getting Started This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/dbxcli:edge with: args: \"dbxcli\" Pull latest image The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/dbxcli:edge Test interactively Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/dbxcli:edge /bin/bash Run a basic command To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/dbxcli:edge dbxcli Fundamentals All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"cardboardci/dbxcli"},{"location":"images/dbxcli/#cardboardcidbxcli","text":"cardboardci/dbxcli is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for interfacing with Dropbox. A command line client for Dropbox built using the Go SDK Supports basic file operations like ls, cp, mkdir, mv (via the Files API) Supports search Supports file revisions and file restore Chunked uploads for large files, paginated listing for large directories Supports a growing set of Team operations You can see the source repository here .","title":"cardboardci/dbxcli"},{"location":"images/dbxcli/#getting-started","text":"This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/dbxcli:edge with: args: \"dbxcli\"","title":"Getting Started"},{"location":"images/dbxcli/#pull-latest-image","text":"The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/dbxcli:edge","title":"Pull latest image"},{"location":"images/dbxcli/#test-interactively","text":"Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/dbxcli:edge /bin/bash","title":"Test interactively"},{"location":"images/dbxcli/#run-a-basic-command","text":"To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/dbxcli:edge dbxcli","title":"Run a basic command"},{"location":"images/dbxcli/#fundamentals","text":"All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"Fundamentals"},{"location":"images/ecr/","text":"cardboardci/ecr cardboardci/ecr is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for pushing docker images to AWS Elastic Container Registry (ECR). The AWS Command Line Interface (CLI) is a unified tool to manage your AWS services. With just one tool to download and configure, you can control multiple AWS services from the command line and automate them through scripts. Getting Started This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/ecr:edge with: args: \"aws --version\" Pull latest image The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/ecr:edge Test interactively Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/ecr:edge /bin/bash Run a basic command To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/ecr:edge aws --version Fundamentals All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"cardboardci/ecr"},{"location":"images/ecr/#cardboardciecr","text":"cardboardci/ecr is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for pushing docker images to AWS Elastic Container Registry (ECR). The AWS Command Line Interface (CLI) is a unified tool to manage your AWS services. With just one tool to download and configure, you can control multiple AWS services from the command line and automate them through scripts.","title":"cardboardci/ecr"},{"location":"images/ecr/#getting-started","text":"This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/ecr:edge with: args: \"aws --version\"","title":"Getting Started"},{"location":"images/ecr/#pull-latest-image","text":"The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/ecr:edge","title":"Pull latest image"},{"location":"images/ecr/#test-interactively","text":"Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/ecr:edge /bin/bash","title":"Test interactively"},{"location":"images/ecr/#run-a-basic-command","text":"To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/ecr:edge aws --version","title":"Run a basic command"},{"location":"images/ecr/#fundamentals","text":"All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"Fundamentals"},{"location":"images/github/","text":"cardboardci/github cardboardci/github is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for working with GitHub. gh is GitHub on the command line. It brings pull requests, issues, and other GitHub concepts to the terminal next to where you are already working with git and your code. Getting Started This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/github:edge with: args: \"gh --version\" Pull latest image The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/github:edge Test interactively Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/github:edge /bin/bash Run a basic command To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/github:edge gh --version Fundamentals All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"cardboardci/github"},{"location":"images/github/#cardboardcigithub","text":"cardboardci/github is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for working with GitHub. gh is GitHub on the command line. It brings pull requests, issues, and other GitHub concepts to the terminal next to where you are already working with git and your code.","title":"cardboardci/github"},{"location":"images/github/#getting-started","text":"This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/github:edge with: args: \"gh --version\"","title":"Getting Started"},{"location":"images/github/#pull-latest-image","text":"The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/github:edge","title":"Pull latest image"},{"location":"images/github/#test-interactively","text":"Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/github:edge /bin/bash","title":"Test interactively"},{"location":"images/github/#run-a-basic-command","text":"To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/github:edge gh --version","title":"Run a basic command"},{"location":"images/github/#fundamentals","text":"All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"Fundamentals"},{"location":"images/gitlab/","text":"cardboardci/gitlab cardboardci/gitlab is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for interacting with GitLab. What is GitLabCLI ? It's a cross platform GitLab command line tool to quickly & naturally perform frequent tasks on GitLab project. It does not force you to hand craft json or use other unnatural ways (for example ids, concatenating of strings) like other CLI's to interact with GitLab. It does not have any dependencies. It's self contained .NET core application - you don't need to have .NET installed for it to work. You can see the source repository here . Getting Started This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/gitlab:edge with: args: \"lab --version\" Pull latest image The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/gitlab:edge Test interactively Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/gitlab:edge /bin/bash Run a basic command To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/gitlab:edge lab --version Fundamentals All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"cardboardci/gitlab"},{"location":"images/gitlab/#cardboardcigitlab","text":"cardboardci/gitlab is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for interacting with GitLab. What is GitLabCLI ? It's a cross platform GitLab command line tool to quickly & naturally perform frequent tasks on GitLab project. It does not force you to hand craft json or use other unnatural ways (for example ids, concatenating of strings) like other CLI's to interact with GitLab. It does not have any dependencies. It's self contained .NET core application - you don't need to have .NET installed for it to work. You can see the source repository here .","title":"cardboardci/gitlab"},{"location":"images/gitlab/#getting-started","text":"This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/gitlab:edge with: args: \"lab --version\"","title":"Getting Started"},{"location":"images/gitlab/#pull-latest-image","text":"The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/gitlab:edge","title":"Pull latest image"},{"location":"images/gitlab/#test-interactively","text":"Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/gitlab:edge /bin/bash","title":"Test interactively"},{"location":"images/gitlab/#run-a-basic-command","text":"To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/gitlab:edge lab --version","title":"Run a basic command"},{"location":"images/gitlab/#fundamentals","text":"All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"Fundamentals"},{"location":"images/hadolint/","text":"cardboardci/hadolint cardboardci/hadolint is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for static analysis of Dockerfiles. A smarter Dockerfile linter that helps you build best practice Docker images. The linter is parsing the Dockerfile into an AST and performs rules on top of the AST. It is standing on the shoulders of ShellCheck to lint the Bash code inside RUN instructions. You can see the source repository here . Getting Started This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/hadolint:edge with: args: \"hadolint --version\" Pull latest image The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/hadolint:edge Test interactively Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/hadolint:edge /bin/bash Run a basic command To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/hadolint:edge hadolint --version Fundamentals All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"cardboardci/hadolint"},{"location":"images/hadolint/#cardboardcihadolint","text":"cardboardci/hadolint is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for static analysis of Dockerfiles. A smarter Dockerfile linter that helps you build best practice Docker images. The linter is parsing the Dockerfile into an AST and performs rules on top of the AST. It is standing on the shoulders of ShellCheck to lint the Bash code inside RUN instructions. You can see the source repository here .","title":"cardboardci/hadolint"},{"location":"images/hadolint/#getting-started","text":"This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/hadolint:edge with: args: \"hadolint --version\"","title":"Getting Started"},{"location":"images/hadolint/#pull-latest-image","text":"The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/hadolint:edge","title":"Pull latest image"},{"location":"images/hadolint/#test-interactively","text":"Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/hadolint:edge /bin/bash","title":"Test interactively"},{"location":"images/hadolint/#run-a-basic-command","text":"To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/hadolint:edge hadolint --version","title":"Run a basic command"},{"location":"images/hadolint/#fundamentals","text":"All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"Fundamentals"},{"location":"images/htmlhint/","text":"cardboardci/htmlhint cardboardci/htmlhint is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for static analysis of HTML. The static code analysis tool you need for your HTML. You can see the source repository here . Getting Started This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/htmlhint:edge with: args: \"htmlhint --version\" Pull latest image The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/htmlhint:edge Test interactively Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/htmlhint:edge /bin/bash Run a basic command To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/htmlhint:edge htmlhint --version Fundamentals All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"cardboardci/htmlhint"},{"location":"images/htmlhint/#cardboardcihtmlhint","text":"cardboardci/htmlhint is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for static analysis of HTML. The static code analysis tool you need for your HTML. You can see the source repository here .","title":"cardboardci/htmlhint"},{"location":"images/htmlhint/#getting-started","text":"This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/htmlhint:edge with: args: \"htmlhint --version\"","title":"Getting Started"},{"location":"images/htmlhint/#pull-latest-image","text":"The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/htmlhint:edge","title":"Pull latest image"},{"location":"images/htmlhint/#test-interactively","text":"Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/htmlhint:edge /bin/bash","title":"Test interactively"},{"location":"images/htmlhint/#run-a-basic-command","text":"To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/htmlhint:edge htmlhint --version","title":"Run a basic command"},{"location":"images/htmlhint/#fundamentals","text":"All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"Fundamentals"},{"location":"images/hugo/","text":"cardboardci/hugo cardboardci/hugo is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for generating static websites with Hugo. Hugo is one of the most popular open-source static site generators. With its amazing speed and flexibility, Hugo makes building websites fun again. You can see the cli reference here . Getting Started This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/hugo:edge with: args: \"hugo version\" Pull latest image The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/hugo:edge Test interactively Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/hugo:edge /bin/bash Run a basic command To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/hugo:edge hugo version Fundamentals All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"cardboardci/hugo"},{"location":"images/hugo/#cardboardcihugo","text":"cardboardci/hugo is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for generating static websites with Hugo. Hugo is one of the most popular open-source static site generators. With its amazing speed and flexibility, Hugo makes building websites fun again. You can see the cli reference here .","title":"cardboardci/hugo"},{"location":"images/hugo/#getting-started","text":"This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/hugo:edge with: args: \"hugo version\"","title":"Getting Started"},{"location":"images/hugo/#pull-latest-image","text":"The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/hugo:edge","title":"Pull latest image"},{"location":"images/hugo/#test-interactively","text":"Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/hugo:edge /bin/bash","title":"Test interactively"},{"location":"images/hugo/#run-a-basic-command","text":"To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/hugo:edge hugo version","title":"Run a basic command"},{"location":"images/hugo/#fundamentals","text":"All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"Fundamentals"},{"location":"images/luacheck/","text":"cardboardci/luacheck cardboardci/luacheck is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for static analysis of Lua. Luacheck is a static analyzer and a linter for Lua. Luacheck detects various issues such as usage of undefined global variables, unused variables and values, accessing uninitialized variables, unreachable code and more. Most aspects of checking are configurable: there are options for defining custom project-related globals, for selecting set of standard globals (version of Lua standard library), for filtering warnings by type and name of related variable, etc. The options can be used on the command line, put into a config or directly into checked files as Lua comments. You can see the cli reference here . Getting Started This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/luacheck:edge with: args: \"luacheck --version\" Pull latest image The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/luacheck:edge Test interactively Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/luacheck:edge /bin/bash Run a basic command To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/luacheck:edge luacheck --version Fundamentals All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"cardboardci/luacheck"},{"location":"images/luacheck/#cardboardciluacheck","text":"cardboardci/luacheck is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for static analysis of Lua. Luacheck is a static analyzer and a linter for Lua. Luacheck detects various issues such as usage of undefined global variables, unused variables and values, accessing uninitialized variables, unreachable code and more. Most aspects of checking are configurable: there are options for defining custom project-related globals, for selecting set of standard globals (version of Lua standard library), for filtering warnings by type and name of related variable, etc. The options can be used on the command line, put into a config or directly into checked files as Lua comments. You can see the cli reference here .","title":"cardboardci/luacheck"},{"location":"images/luacheck/#getting-started","text":"This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/luacheck:edge with: args: \"luacheck --version\"","title":"Getting Started"},{"location":"images/luacheck/#pull-latest-image","text":"The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/luacheck:edge","title":"Pull latest image"},{"location":"images/luacheck/#test-interactively","text":"Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/luacheck:edge /bin/bash","title":"Test interactively"},{"location":"images/luacheck/#run-a-basic-command","text":"To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/luacheck:edge luacheck --version","title":"Run a basic command"},{"location":"images/luacheck/#fundamentals","text":"All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"Fundamentals"},{"location":"images/markdownlint/","text":"cardboardci/markdownlint cardboardci/markdownlint is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for static analysis of Markdown. A tool to check markdown files and flag style issues. To have markdownlint check your markdown files, simply run mdl with the filenames as a parameter: mdl README.md Markdownlint can also take a directory, and it will scan all markdown files within the directory (and nested directories): mdl docs/ You can see the cli reference here . Getting Started This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/markdownlint:edge with: args: \"markdownlint --version\" Pull latest image The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/markdownlint:edge Test interactively Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/markdownlint:edge /bin/bash Run a basic command To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/markdownlint:edge markdownlint --version Fundamentals All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"cardboardci/markdownlint"},{"location":"images/markdownlint/#cardboardcimarkdownlint","text":"cardboardci/markdownlint is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for static analysis of Markdown. A tool to check markdown files and flag style issues. To have markdownlint check your markdown files, simply run mdl with the filenames as a parameter: mdl README.md Markdownlint can also take a directory, and it will scan all markdown files within the directory (and nested directories): mdl docs/ You can see the cli reference here .","title":"cardboardci/markdownlint"},{"location":"images/markdownlint/#getting-started","text":"This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/markdownlint:edge with: args: \"markdownlint --version\"","title":"Getting Started"},{"location":"images/markdownlint/#pull-latest-image","text":"The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/markdownlint:edge","title":"Pull latest image"},{"location":"images/markdownlint/#test-interactively","text":"Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/markdownlint:edge /bin/bash","title":"Test interactively"},{"location":"images/markdownlint/#run-a-basic-command","text":"To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/markdownlint:edge markdownlint --version","title":"Run a basic command"},{"location":"images/markdownlint/#fundamentals","text":"All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"Fundamentals"},{"location":"images/netlify/","text":"cardboardci/netlify cardboardci/netlify is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for deploying to netlify. The Netlify CLI facilitates the deployment of websites to Netlify, to improve the site building experience. You can see the cli reference here . Getting Started This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/netlify:edge with: args: \"netlify --version\" Pull latest image The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/netlify:edge Test interactively Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/netlify:edge /bin/bash Run a basic command To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/netlify:edge netlify --version Fundamentals All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"cardboardci/netlify"},{"location":"images/netlify/#cardboardcinetlify","text":"cardboardci/netlify is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for deploying to netlify. The Netlify CLI facilitates the deployment of websites to Netlify, to improve the site building experience. You can see the cli reference here .","title":"cardboardci/netlify"},{"location":"images/netlify/#getting-started","text":"This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/netlify:edge with: args: \"netlify --version\"","title":"Getting Started"},{"location":"images/netlify/#pull-latest-image","text":"The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/netlify:edge","title":"Pull latest image"},{"location":"images/netlify/#test-interactively","text":"Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/netlify:edge /bin/bash","title":"Test interactively"},{"location":"images/netlify/#run-a-basic-command","text":"To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/netlify:edge netlify --version","title":"Run a basic command"},{"location":"images/netlify/#fundamentals","text":"All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"Fundamentals"},{"location":"images/pdf2htmlex/","text":"cardboardci/pdf2htmlex cardboardci/pdf2htmlex is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for converting PDFs to HTML. pdf2htmlEX renders PDF files in HTML, utilizing modern Web technologies. Academic papers with lots of formulas and figures? Magazines with complicated layouts? No problem! Features: Native HTML text with precise font and location. Flexible output: all-in-one HTML or on demand page loading (needs JavaScript). Moderate file size, sometimes even smaller than PDF. Supporting links, outlines (bookmarks), printing, SVG background, Type 3 fonts and more. You can see the cli reference here . Getting Started This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/pdf2htmlex:edge with: args: \"pdf2htmlex --version\" Pull latest image The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/pdf2htmlex:edge Test interactively Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/pdf2htmlex:edge /bin/bash Run a basic command To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/pdf2htmlex:edge pdf2htmlex --version Fundamentals All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"cardboardci/pdf2htmlex"},{"location":"images/pdf2htmlex/#cardboardcipdf2htmlex","text":"cardboardci/pdf2htmlex is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for converting PDFs to HTML. pdf2htmlEX renders PDF files in HTML, utilizing modern Web technologies. Academic papers with lots of formulas and figures? Magazines with complicated layouts? No problem! Features: Native HTML text with precise font and location. Flexible output: all-in-one HTML or on demand page loading (needs JavaScript). Moderate file size, sometimes even smaller than PDF. Supporting links, outlines (bookmarks), printing, SVG background, Type 3 fonts and more. You can see the cli reference here .","title":"cardboardci/pdf2htmlex"},{"location":"images/pdf2htmlex/#getting-started","text":"This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/pdf2htmlex:edge with: args: \"pdf2htmlex --version\"","title":"Getting Started"},{"location":"images/pdf2htmlex/#pull-latest-image","text":"The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/pdf2htmlex:edge","title":"Pull latest image"},{"location":"images/pdf2htmlex/#test-interactively","text":"Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/pdf2htmlex:edge /bin/bash","title":"Test interactively"},{"location":"images/pdf2htmlex/#run-a-basic-command","text":"To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/pdf2htmlex:edge pdf2htmlex --version","title":"Run a basic command"},{"location":"images/pdf2htmlex/#fundamentals","text":"All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"Fundamentals"},{"location":"images/pdftools/","text":"cardboardci/pdftools cardboardci/pdftools is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for working with PDFs. Scientific articles are typically locked away in PDF format, a format designed primarily for printing but not so great for searching or indexing. The new pdftools package allows for extracting text and metadata from pdf files in R. From the extracted plain-text one could find articles discussing a particular drug or species name, without having to rely on publishers providing metadata, or pay-walled search engines. You can see the cli reference here . Getting Started This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/pdftools:edge with: args: \"pdftools --version\" Pull latest image The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/pdftools:edge Test interactively Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/pdftools:edge /bin/bash Run a basic command To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/pdftools:edge pdftools --version Fundamentals All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"cardboardci/pdftools"},{"location":"images/pdftools/#cardboardcipdftools","text":"cardboardci/pdftools is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for working with PDFs. Scientific articles are typically locked away in PDF format, a format designed primarily for printing but not so great for searching or indexing. The new pdftools package allows for extracting text and metadata from pdf files in R. From the extracted plain-text one could find articles discussing a particular drug or species name, without having to rely on publishers providing metadata, or pay-walled search engines. You can see the cli reference here .","title":"cardboardci/pdftools"},{"location":"images/pdftools/#getting-started","text":"This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/pdftools:edge with: args: \"pdftools --version\"","title":"Getting Started"},{"location":"images/pdftools/#pull-latest-image","text":"The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/pdftools:edge","title":"Pull latest image"},{"location":"images/pdftools/#test-interactively","text":"Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/pdftools:edge /bin/bash","title":"Test interactively"},{"location":"images/pdftools/#run-a-basic-command","text":"To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/pdftools:edge pdftools --version","title":"Run a basic command"},{"location":"images/pdftools/#fundamentals","text":"All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"Fundamentals"},{"location":"images/psscriptanalyzer/","text":"cardboardci/psscriptanalyzer cardboardci/psscriptanalyzer is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for static analysis of PowerShell. PSScriptAnalyzer is a static code checker for Windows PowerShell modules and scripts. PSScriptAnalyzer checks the quality of Windows PowerShell code by running a set of rules. The rules are based on PowerShell best practices identified by PowerShell Team and the community. It generates DiagnosticResults (errors and warnings) to inform users about potential code defects and suggests possible solutions for improvements. You can see the cli reference here . Getting Started This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/psscriptanalyzer:edge with: args: \"PSFormatter ...\" Pull latest image The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/psscriptanalyzer:edge Test interactively Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/psscriptanalyzer:edge /bin/bash Run a basic command To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/psscriptanalyzer:edge PSFormatter -ScriptDefinition \"\\\" Write-Output 'hello world'\\\"\" Fundamentals All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"cardboardci/psscriptanalyzer"},{"location":"images/psscriptanalyzer/#cardboardcipsscriptanalyzer","text":"cardboardci/psscriptanalyzer is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for static analysis of PowerShell. PSScriptAnalyzer is a static code checker for Windows PowerShell modules and scripts. PSScriptAnalyzer checks the quality of Windows PowerShell code by running a set of rules. The rules are based on PowerShell best practices identified by PowerShell Team and the community. It generates DiagnosticResults (errors and warnings) to inform users about potential code defects and suggests possible solutions for improvements. You can see the cli reference here .","title":"cardboardci/psscriptanalyzer"},{"location":"images/psscriptanalyzer/#getting-started","text":"This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/psscriptanalyzer:edge with: args: \"PSFormatter ...\"","title":"Getting Started"},{"location":"images/psscriptanalyzer/#pull-latest-image","text":"The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/psscriptanalyzer:edge","title":"Pull latest image"},{"location":"images/psscriptanalyzer/#test-interactively","text":"Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/psscriptanalyzer:edge /bin/bash","title":"Test interactively"},{"location":"images/psscriptanalyzer/#run-a-basic-command","text":"To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/psscriptanalyzer:edge PSFormatter -ScriptDefinition \"\\\" Write-Output 'hello world'\\\"\"","title":"Run a basic command"},{"location":"images/psscriptanalyzer/#fundamentals","text":"All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"Fundamentals"},{"location":"images/pylint/","text":"cardboardci/pylint cardboardci/pylint is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for linting of Python. Pylint is a Python static code analysis tool which looks for programming errors, helps enforcing a coding standard, sniffs for code smells and offers simple refactoring suggestions. It's highly configurable, having special pragmas to control its errors and warnings from within your code, as well as from an extensive configuration file. It is also possible to write your own plugins for adding your own checks or for extending pylint in one way or another. You can see the cli reference here . Getting Started This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/pylint:edge with: args: \"pylint --version\" Pull latest image The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/pylint:edge Test interactively Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/pylint:edge /bin/bash Run a basic command To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/pylint:edge pylint --version Fundamentals All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"cardboardci/pylint"},{"location":"images/pylint/#cardboardcipylint","text":"cardboardci/pylint is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for linting of Python. Pylint is a Python static code analysis tool which looks for programming errors, helps enforcing a coding standard, sniffs for code smells and offers simple refactoring suggestions. It's highly configurable, having special pragmas to control its errors and warnings from within your code, as well as from an extensive configuration file. It is also possible to write your own plugins for adding your own checks or for extending pylint in one way or another. You can see the cli reference here .","title":"cardboardci/pylint"},{"location":"images/pylint/#getting-started","text":"This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/pylint:edge with: args: \"pylint --version\"","title":"Getting Started"},{"location":"images/pylint/#pull-latest-image","text":"The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/pylint:edge","title":"Pull latest image"},{"location":"images/pylint/#test-interactively","text":"Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/pylint:edge /bin/bash","title":"Test interactively"},{"location":"images/pylint/#run-a-basic-command","text":"To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/pylint:edge pylint --version","title":"Run a basic command"},{"location":"images/pylint/#fundamentals","text":"All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"Fundamentals"},{"location":"images/rsvg/","text":"cardboardci/rsvg cardboardci/rsvg is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for working with Scalable Vector Graphics (SVG). A utility to render Scalable Vector Graphics (SVG), associated with the GNOME Project. It renders SVG files to Cairo surfaces. Cairo is the 2D, antialiased drawing library that GNOME uses to draw things to the screen or to generate output for printing. You can see the cli reference here . Getting Started This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/rsvg:edge with: args: \"rsvg-convert --version\" Pull latest image The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/rsvg:edge Test interactively Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/rsvg:edge /bin/bash Run a basic command To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/rsvg:edge rsvg-convert --version Fundamentals All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"cardboardci/rsvg"},{"location":"images/rsvg/#cardboardcirsvg","text":"cardboardci/rsvg is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for working with Scalable Vector Graphics (SVG). A utility to render Scalable Vector Graphics (SVG), associated with the GNOME Project. It renders SVG files to Cairo surfaces. Cairo is the 2D, antialiased drawing library that GNOME uses to draw things to the screen or to generate output for printing. You can see the cli reference here .","title":"cardboardci/rsvg"},{"location":"images/rsvg/#getting-started","text":"This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/rsvg:edge with: args: \"rsvg-convert --version\"","title":"Getting Started"},{"location":"images/rsvg/#pull-latest-image","text":"The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/rsvg:edge","title":"Pull latest image"},{"location":"images/rsvg/#test-interactively","text":"Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/rsvg:edge /bin/bash","title":"Test interactively"},{"location":"images/rsvg/#run-a-basic-command","text":"To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/rsvg:edge rsvg-convert --version","title":"Run a basic command"},{"location":"images/rsvg/#fundamentals","text":"All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"Fundamentals"},{"location":"images/rubocop/","text":"cardboardci/rubocop cardboardci/rubocop is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for static analysis of Ruby. RuboCop is a Ruby static code analyzer and code formatter. Out of the box it will enforce many of the guidelines outlined in the community Ruby Style Guide. RuboCop is extremely flexible and most aspects of its behavior can be tweaked via various configuration options. You can see the cli reference here . Getting Started This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/rubocop:edge with: args: \"rubocop --version\" Pull latest image The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/rubocop:edge Test interactively Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/rubocop:edge /bin/bash Run a basic command To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/rubocop:edge rubocop --version Fundamentals All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"cardboardci/rubocop"},{"location":"images/rubocop/#cardboardcirubocop","text":"cardboardci/rubocop is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for static analysis of Ruby. RuboCop is a Ruby static code analyzer and code formatter. Out of the box it will enforce many of the guidelines outlined in the community Ruby Style Guide. RuboCop is extremely flexible and most aspects of its behavior can be tweaked via various configuration options. You can see the cli reference here .","title":"cardboardci/rubocop"},{"location":"images/rubocop/#getting-started","text":"This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/rubocop:edge with: args: \"rubocop --version\"","title":"Getting Started"},{"location":"images/rubocop/#pull-latest-image","text":"The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/rubocop:edge","title":"Pull latest image"},{"location":"images/rubocop/#test-interactively","text":"Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/rubocop:edge /bin/bash","title":"Test interactively"},{"location":"images/rubocop/#run-a-basic-command","text":"To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/rubocop:edge rubocop --version","title":"Run a basic command"},{"location":"images/rubocop/#fundamentals","text":"All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"Fundamentals"},{"location":"images/shellcheck/","text":"cardboardci/shellcheck cardboardci/shellcheck is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for static analysis of Shell scripts. ShellCheck is a GPLv3 tool that gives warnings and suggestions for bash/sh shell scripts: The goals of ShellCheck are: To point out and clarify typical beginner's syntax issues that cause a shell to give cryptic error messages. To point out and clarify typical intermediate level semantic problems that cause a shell to behave strangely and counter-intuitively. To point out subtle caveats, corner cases and pitfalls that may cause an advanced user's otherwise working script to fail under future circumstances. You can see the cli reference here . Getting Started This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/shellcheck:edge with: args: \"shellcheck --version\" Pull latest image The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/shellcheck:edge Test interactively Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/shellcheck:edge /bin/bash Run a basic command To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/shellcheck:edge shellcheck --version Fundamentals All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"cardboardci/shellcheck"},{"location":"images/shellcheck/#cardboardcishellcheck","text":"cardboardci/shellcheck is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for static analysis of Shell scripts. ShellCheck is a GPLv3 tool that gives warnings and suggestions for bash/sh shell scripts: The goals of ShellCheck are: To point out and clarify typical beginner's syntax issues that cause a shell to give cryptic error messages. To point out and clarify typical intermediate level semantic problems that cause a shell to behave strangely and counter-intuitively. To point out subtle caveats, corner cases and pitfalls that may cause an advanced user's otherwise working script to fail under future circumstances. You can see the cli reference here .","title":"cardboardci/shellcheck"},{"location":"images/shellcheck/#getting-started","text":"This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/shellcheck:edge with: args: \"shellcheck --version\"","title":"Getting Started"},{"location":"images/shellcheck/#pull-latest-image","text":"The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/shellcheck:edge","title":"Pull latest image"},{"location":"images/shellcheck/#test-interactively","text":"Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/shellcheck:edge /bin/bash","title":"Test interactively"},{"location":"images/shellcheck/#run-a-basic-command","text":"To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/shellcheck:edge shellcheck --version","title":"Run a basic command"},{"location":"images/shellcheck/#fundamentals","text":"All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"Fundamentals"},{"location":"images/stylelint/","text":"cardboardci/stylelint cardboardci/stylelint is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for linting modern web files. A mighty, modern linter that helps you avoid errors and enforce conventions in your styles. It's mighty because it: understands the latest CSS syntax including custom properties and level 4 selectors extracts embedded styles from HTML, markdown and CSS-in-JS object & template literals parses CSS-like syntaxes like SCSS, Sass, Less and SugarSS has over 170 built-in rules to catch errors, apply limits and enforce stylistic conventions supports plugins so you can create your own rules or make use of plugins written by the community automatically fixes some violations (experimental feature) is well tested with over 10000 unit tests supports shareable configs that you can extend or create your own of is unopinionated so you can tailor the linter to your exact needs You can see the cli reference here . Getting Started This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/stylelint:edge with: args: \"stylelint --version\" Pull latest image The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/stylelint:edge Test interactively Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/stylelint:edge /bin/bash Run a basic command To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/stylelint:edge stylelint --version Fundamentals All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"cardboardci/stylelint"},{"location":"images/stylelint/#cardboardcistylelint","text":"cardboardci/stylelint is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for linting modern web files. A mighty, modern linter that helps you avoid errors and enforce conventions in your styles. It's mighty because it: understands the latest CSS syntax including custom properties and level 4 selectors extracts embedded styles from HTML, markdown and CSS-in-JS object & template literals parses CSS-like syntaxes like SCSS, Sass, Less and SugarSS has over 170 built-in rules to catch errors, apply limits and enforce stylistic conventions supports plugins so you can create your own rules or make use of plugins written by the community automatically fixes some violations (experimental feature) is well tested with over 10000 unit tests supports shareable configs that you can extend or create your own of is unopinionated so you can tailor the linter to your exact needs You can see the cli reference here .","title":"cardboardci/stylelint"},{"location":"images/stylelint/#getting-started","text":"This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/stylelint:edge with: args: \"stylelint --version\"","title":"Getting Started"},{"location":"images/stylelint/#pull-latest-image","text":"The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/stylelint:edge","title":"Pull latest image"},{"location":"images/stylelint/#test-interactively","text":"Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/stylelint:edge /bin/bash","title":"Test interactively"},{"location":"images/stylelint/#run-a-basic-command","text":"To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/stylelint:edge stylelint --version","title":"Run a basic command"},{"location":"images/stylelint/#fundamentals","text":"All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"Fundamentals"},{"location":"images/surge/","text":"cardboardci/surge cardboardci/surge is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for deploying to surge.sh. This is the CLI client for the surge.sh hosted service. It\u2019s what gets installed when you run npm install -g surge . This CLI library manages access tokens locally and handles the upload and subsequent reporting when you publish a project using surge. You can see the cli reference here . Getting Started This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/surge:edge with: args: \"surge --version\" Pull latest image The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/surge:edge Test interactively Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/surge:edge /bin/bash Run a basic command To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/surge:edge surge --version Fundamentals All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"cardboardci/surge"},{"location":"images/surge/#cardboardcisurge","text":"cardboardci/surge is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for deploying to surge.sh. This is the CLI client for the surge.sh hosted service. It\u2019s what gets installed when you run npm install -g surge . This CLI library manages access tokens locally and handles the upload and subsequent reporting when you publish a project using surge. You can see the cli reference here .","title":"cardboardci/surge"},{"location":"images/surge/#getting-started","text":"This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/surge:edge with: args: \"surge --version\"","title":"Getting Started"},{"location":"images/surge/#pull-latest-image","text":"The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/surge:edge","title":"Pull latest image"},{"location":"images/surge/#test-interactively","text":"Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/surge:edge /bin/bash","title":"Test interactively"},{"location":"images/surge/#run-a-basic-command","text":"To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/surge:edge surge --version","title":"Run a basic command"},{"location":"images/surge/#fundamentals","text":"All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"Fundamentals"},{"location":"images/svgtools/","text":"cardboardci/svgtools cardboardci/svgtools is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for working with Scalable Vector Graphics (SVG). SVG Tools are a collection of tools for working with vector graphics. You can see the cli reference here . Getting Started This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/svgtools:edge with: args: \"rsvg-convert --version\" Pull latest image The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/svgtools:edge Test interactively Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/svgtools:edge /bin/bash Run a basic command To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/svgtools:edge rsvg-convert --version Fundamentals All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"cardboardci/svgtools"},{"location":"images/svgtools/#cardboardcisvgtools","text":"cardboardci/svgtools is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for working with Scalable Vector Graphics (SVG). SVG Tools are a collection of tools for working with vector graphics. You can see the cli reference here .","title":"cardboardci/svgtools"},{"location":"images/svgtools/#getting-started","text":"This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/svgtools:edge with: args: \"rsvg-convert --version\"","title":"Getting Started"},{"location":"images/svgtools/#pull-latest-image","text":"The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/svgtools:edge","title":"Pull latest image"},{"location":"images/svgtools/#test-interactively","text":"Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/svgtools:edge /bin/bash","title":"Test interactively"},{"location":"images/svgtools/#run-a-basic-command","text":"To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/svgtools:edge rsvg-convert --version","title":"Run a basic command"},{"location":"images/svgtools/#fundamentals","text":"All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"Fundamentals"},{"location":"images/tflint/","text":"cardboardci/tflint cardboardci/tflint is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for static analysis of Terraform. TFLint is a Terraform linter focused on possible errors, best practices, etc. You can see the cli reference here . Getting Started This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/tflint:edge with: args: \"tflint --version\" Pull latest image The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/tflint:edge Test interactively Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/tflint:edge /bin/bash Run a basic command To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/tflint:edge tflint --version Fundamentals All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"cardboardci/tflint"},{"location":"images/tflint/#cardboardcitflint","text":"cardboardci/tflint is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for static analysis of Terraform. TFLint is a Terraform linter focused on possible errors, best practices, etc. You can see the cli reference here .","title":"cardboardci/tflint"},{"location":"images/tflint/#getting-started","text":"This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/tflint:edge with: args: \"tflint --version\"","title":"Getting Started"},{"location":"images/tflint/#pull-latest-image","text":"The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/tflint:edge","title":"Pull latest image"},{"location":"images/tflint/#test-interactively","text":"Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/tflint:edge /bin/bash","title":"Test interactively"},{"location":"images/tflint/#run-a-basic-command","text":"To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/tflint:edge tflint --version","title":"Run a basic command"},{"location":"images/tflint/#fundamentals","text":"All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"Fundamentals"},{"location":"images/wkhtmltopdf/","text":"cardboardci/wkhtmltopdf cardboardci/wkhtmltopdf is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for converting from HTML to PDF. wkhtmltopdf and wkhtmltoimage are open source (LGPLv3) command line tools to render HTML into PDF and various image formats using the Qt WebKit rendering engine. These run entirely \"headless\" and do not require a display or display service. You can see the cli reference here . Getting Started This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/wkhtmltopdf:edge with: args: \"wkhtmltopdf --version\" Pull latest image The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/wkhtmltopdf:edge Test interactively Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/wkhtmltopdf:edge /bin/bash Run a basic command To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/wkhtmltopdf:edge wkhtmltopdf --version Fundamentals All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"cardboardci/wkhtmltopdf"},{"location":"images/wkhtmltopdf/#cardboardciwkhtmltopdf","text":"cardboardci/wkhtmltopdf is a Docker image built with continuous integration builds in mind. Each tag contains any binaries and tools that are required for builds to complete successfully in a continuous integration environment. This includes jq , curl , bash and utilities for converting from HTML to PDF. wkhtmltopdf and wkhtmltoimage are open source (LGPLv3) command line tools to render HTML into PDF and various image formats using the Qt WebKit rendering engine. These run entirely \"headless\" and do not require a display or display service. You can see the cli reference here .","title":"cardboardci/wkhtmltopdf"},{"location":"images/wkhtmltopdf/#getting-started","text":"This image can be used with the docker type for different types of continuous integration platforms. For example: # GitHub Actions jobs: my_first_job: steps: - name: My first step uses: docker://ghcr.io/cardboardci/wkhtmltopdf:edge with: args: \"wkhtmltopdf --version\"","title":"Getting Started"},{"location":"images/wkhtmltopdf/#pull-latest-image","text":"The edge or latest version of the image is available with the tag edge . This isn't intended to long term use, but for working with the latest version of the image. To pull the latest image, run the following: docker pull ghcr.io/cardboardci/wkhtmltopdf:edge","title":"Pull latest image"},{"location":"images/wkhtmltopdf/#test-interactively","text":"Sometimes it can be useful to run the image in an interactive shell for experimentation. To shell into an image, run the following: docker run -it ghcr.io/cardboardci/wkhtmltopdf:edge /bin/bash","title":"Test interactively"},{"location":"images/wkhtmltopdf/#run-a-basic-command","text":"To run a single command from the context of the docker image, run the following: docker run -it -v `pwd`:/workspace ghcr.io/cardboardci/wkhtmltopdf:edge wkhtmltopdf --version","title":"Run a basic command"},{"location":"images/wkhtmltopdf/#fundamentals","text":"All images in the CardboardCI namespace are built from cardboardci/base. This image is intended to provide a common set of dependencies and expectations about how the images will behave. The image will always be built from the base image, to ensure any changes seen in the base are included in the downstream image.","title":"Fundamentals"}]}